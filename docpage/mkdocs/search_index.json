{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome\n\n\nCurrent version: \nBETA 0.9.0\n, NYR\n\n\nForeward\n\n\nI would like to extend my sincere thanks for purchasing the Smithy Procedural Asset Framework.\n  If you have any issues or questions not covered in these documents, please \ncontact me\n and I will do my best to resolve the problem as quickly as possible.\n\n\n\n  If you have a pressing issue please don\u2019t go to the forums first, as I might not see it right away.\n\n\n\n\nIf you didn\u2019t yet buy this asset, I hope that exploring this manual will convince you of its usefulness in your Unity workflow. If not, I hope it\u2019s at least an enjoyable read and might give you a few new ideas for your own projects.\n\n\nI plan to continue to develop and extend this system, and am constantly looking for feedback and ideas. If Smithy is missing something that you\u2019d like to see please comment on the \nUnity Forums thread\n.\n\n\nThanks again, and if you create anything using Smithy, I\u2019d love to take a look!\n\n\nUsing this Site\n\n\nNearly every control in the Smithy editor links back to this site. If at any time in the Unity editor you need more information, hold  \nALT\n and hover over an element. If it becomes highlighted (the cursor will also turn into a link pointer) click it, and a browser window will be opened to the relevant help page.\n\n\nOtherwise, the site navigation is located at the top of the window, and in-page navigation is on the left-hand side of every page. \nTeal\n links can will lead you to further information about the topic.\n\n\nOverview\n\n\nSmithy is a tool that helps you create assets procedurally, rather than manually.\n  Smithy works through a component called a \nSmithy Adapter\n. This adapter sits on a GameObject - any GameObject - and holds \nNodes\n. Nodes are grouped into \nPlugs\n (they connect to other objects) and \nSockets\n (they accept plugs). Nodes can sit anywhere in space relative to the GameObject's Transform, but Smithy is focused around adding nodes directly to object Meshes.\n\n\n\n\nNodes take a number of parameters, set in the adapter's \ncustom inspector\n. These include where and how sockets and plugs link together.\n\n\nIn your code, you'll create \nGenerator objects\n, you can pass these a GameObject with an Adapter. Smithy will find the socket nodes on that adapter, and select and instantiate objects that contain matching plug nodes. These plug objects are aligned and positioned with respect to the socket nodes (so nodes on mesh surfaces will seem to be physically connected together -- think LEGO).\n\n\n\n\nThis process happens recursively. Smithy checks newly instantiated objects for socket nodes, then generates plug objects for them as well, creating a GameObject hierarchy as simple or complex as you could want.\n\n\n\n\nSmithy \nonly\n manages the instantiation, parenting, and positioning of GameObjects (and, optionally, Materials). It doesn't interact with, or require, any other component. This means you can use Smithy to create object hierarchies with complex component behavior through scripts, other Asset utilities, and Unity's built-in component menu. Procedural AI behavior, game items, dynamic maps, vehicles, creatures, and anything else that can potentially be created by the computer, can be handled by Smithy.\n\n\n\n\nSmithy is probably best explained by way of example, and there are a few thouroughly-explained demos in this documentation:\n\n\nDemos and Tutorials\n\n\n\n\nTo get started quickly, try the \nQuick-Start Guide\n\n\nThe \nStrategy Game Tile Demo\n will teach you how to generate complex scenery that looks hand-made, using only a few meshes and textures. The tutorial focuses on how to prepare assets and Smithy Adapters, and how to use \njitter\n and \nMaterial options\n for maximum effect.\n\n\nThe \nFPS Arsenal Demo\n will teach you how to use Smithy and your own component scripts to create a \nBorderlands\n-style procedural gun generator for an FPS game. The tutorial focuses on how to design and implement custom component scripts so Smithy produces output that has the values and behavior you want.\n\n\nThe \nRPG Hero\n example will teach you how to use Smithy in a more abstract way, and create 2D RPG characters with stats and fluff, as well as procedurally generated dialogue and quests. The tutorial focuses on using Smithy on GameObjects without meshes, and how to combine Smithy with other procedural generation techniques to give even more depth to procedurally created assets.\n\n\n\n\n\n  The source code and resources for each demo are available for download on the tutorial pages.\n\n\n\n\nInstallation and Setup\n\n\nThe Smithy Asset package can be downloaded from the \nUnity Asset Store\n and, from there, imported into an existing project. All files included in the package are required. Demo assets and examples can be downloaded from individual tutorial pages in this site.\n\n\nSmithy requires no additional setup, and you can immediately begin adding \nAdapters\n and \nNodes\n. However, if it's your first time using Smithy, reading the \nQuick Start Tutorial\n is strongly recommended.\n\n\nContact\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTwitter\n\n\nE-Mail\n\n\nSmithy Homepage\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnity Forums Thread\n\n\nAsset Store Page\n\n\nReport a Problem", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome", 
            "text": "Current version:  BETA 0.9.0 , NYR", 
            "title": "Welcome"
        }, 
        {
            "location": "/#foreward", 
            "text": "I would like to extend my sincere thanks for purchasing the Smithy Procedural Asset Framework.\n  If you have any issues or questions not covered in these documents, please  contact me  and I will do my best to resolve the problem as quickly as possible.  \n  If you have a pressing issue please don\u2019t go to the forums first, as I might not see it right away.  If you didn\u2019t yet buy this asset, I hope that exploring this manual will convince you of its usefulness in your Unity workflow. If not, I hope it\u2019s at least an enjoyable read and might give you a few new ideas for your own projects.  I plan to continue to develop and extend this system, and am constantly looking for feedback and ideas. If Smithy is missing something that you\u2019d like to see please comment on the  Unity Forums thread .  Thanks again, and if you create anything using Smithy, I\u2019d love to take a look!", 
            "title": "Foreward"
        }, 
        {
            "location": "/#using-this-site", 
            "text": "Nearly every control in the Smithy editor links back to this site. If at any time in the Unity editor you need more information, hold   ALT  and hover over an element. If it becomes highlighted (the cursor will also turn into a link pointer) click it, and a browser window will be opened to the relevant help page.  Otherwise, the site navigation is located at the top of the window, and in-page navigation is on the left-hand side of every page.  Teal  links can will lead you to further information about the topic.", 
            "title": "Using this Site"
        }, 
        {
            "location": "/#overview", 
            "text": "Smithy is a tool that helps you create assets procedurally, rather than manually.\n  Smithy works through a component called a  Smithy Adapter . This adapter sits on a GameObject - any GameObject - and holds  Nodes . Nodes are grouped into  Plugs  (they connect to other objects) and  Sockets  (they accept plugs). Nodes can sit anywhere in space relative to the GameObject's Transform, but Smithy is focused around adding nodes directly to object Meshes.   Nodes take a number of parameters, set in the adapter's  custom inspector . These include where and how sockets and plugs link together.  In your code, you'll create  Generator objects , you can pass these a GameObject with an Adapter. Smithy will find the socket nodes on that adapter, and select and instantiate objects that contain matching plug nodes. These plug objects are aligned and positioned with respect to the socket nodes (so nodes on mesh surfaces will seem to be physically connected together -- think LEGO).   This process happens recursively. Smithy checks newly instantiated objects for socket nodes, then generates plug objects for them as well, creating a GameObject hierarchy as simple or complex as you could want.   Smithy  only  manages the instantiation, parenting, and positioning of GameObjects (and, optionally, Materials). It doesn't interact with, or require, any other component. This means you can use Smithy to create object hierarchies with complex component behavior through scripts, other Asset utilities, and Unity's built-in component menu. Procedural AI behavior, game items, dynamic maps, vehicles, creatures, and anything else that can potentially be created by the computer, can be handled by Smithy.   Smithy is probably best explained by way of example, and there are a few thouroughly-explained demos in this documentation:", 
            "title": "Overview"
        }, 
        {
            "location": "/#demos-and-tutorials", 
            "text": "To get started quickly, try the  Quick-Start Guide  The  Strategy Game Tile Demo  will teach you how to generate complex scenery that looks hand-made, using only a few meshes and textures. The tutorial focuses on how to prepare assets and Smithy Adapters, and how to use  jitter  and  Material options  for maximum effect.  The  FPS Arsenal Demo  will teach you how to use Smithy and your own component scripts to create a  Borderlands -style procedural gun generator for an FPS game. The tutorial focuses on how to design and implement custom component scripts so Smithy produces output that has the values and behavior you want.  The  RPG Hero  example will teach you how to use Smithy in a more abstract way, and create 2D RPG characters with stats and fluff, as well as procedurally generated dialogue and quests. The tutorial focuses on using Smithy on GameObjects without meshes, and how to combine Smithy with other procedural generation techniques to give even more depth to procedurally created assets.   \n  The source code and resources for each demo are available for download on the tutorial pages.", 
            "title": "Demos and Tutorials"
        }, 
        {
            "location": "/#installation-and-setup", 
            "text": "The Smithy Asset package can be downloaded from the  Unity Asset Store  and, from there, imported into an existing project. All files included in the package are required. Demo assets and examples can be downloaded from individual tutorial pages in this site.  Smithy requires no additional setup, and you can immediately begin adding  Adapters  and  Nodes . However, if it's your first time using Smithy, reading the  Quick Start Tutorial  is strongly recommended.", 
            "title": "Installation and Setup"
        }, 
        {
            "location": "/#contact", 
            "text": "Twitter  E-Mail  Smithy Homepage         Unity Forums Thread  Asset Store Page  Report a Problem", 
            "title": "Contact"
        }, 
        {
            "location": "/demos_tutorials/quick_start/", 
            "text": "Live Demo\n\n\n![alt text]\ndemo image\n\n\nSource\n\n\nIn this demo we'll learn\n\n\nSetup\n\n\nCreating Smithy-Enabled Objects\n\n\nCreating and Configuring a Socket Object\n\n\nCreating and Configuring Plug Objects\n\n\nTesting in the Assembler\n\n\nRuntime Generation Coding\n\n\ndemo.cs\n\n\nTesting in Game Mode\n\n\nNext Steps\n\n\nTo learn about generating interesting visual assets through jitter controls and tag management, check out the \nStrategy Game Tile Tutorial\n\n\nFor a focus on equipping Smithy-generated objects with important data, behaviors, and components, check out the \nFPS Arsenal Tutorial\n\n\nTo see how Smithy can be used to generate content in a 2D, data-centric environment, check out the \nRPG Hero Tutorial", 
            "title": "Quick Start"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#live-demo", 
            "text": "![alt text] demo image  Source  In this demo we'll learn", 
            "title": "Live Demo"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#setup", 
            "text": "", 
            "title": "Setup"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#creating-smithy-enabled-objects", 
            "text": "", 
            "title": "Creating Smithy-Enabled Objects"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#creating-and-configuring-a-socket-object", 
            "text": "", 
            "title": "Creating and Configuring a Socket Object"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#creating-and-configuring-plug-objects", 
            "text": "", 
            "title": "Creating and Configuring Plug Objects"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#testing-in-the-assembler", 
            "text": "", 
            "title": "Testing in the Assembler"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#runtime-generation-coding", 
            "text": "", 
            "title": "Runtime Generation Coding"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#democs", 
            "text": "", 
            "title": "demo.cs"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#testing-in-game-mode", 
            "text": "", 
            "title": "Testing in Game Mode"
        }, 
        {
            "location": "/demos_tutorials/quick_start/#next-steps", 
            "text": "To learn about generating interesting visual assets through jitter controls and tag management, check out the  Strategy Game Tile Tutorial  For a focus on equipping Smithy-generated objects with important data, behaviors, and components, check out the  FPS Arsenal Tutorial  To see how Smithy can be used to generate content in a 2D, data-centric environment, check out the  RPG Hero Tutorial", 
            "title": "Next Steps"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/", 
            "text": "Strategy Game Tile Tutorial\n\n\nLive Demo\n\n\nIntroduction\n\n\nIn this tutorial we'll be using Smithy to procedurally generate swampland tiles for a strategy game.\n\n\nIf you haven't yet, I recommend checking out the \nQuick Start Tutorial\n first. This tutorial builds off of some of the basics covered in the quick start.\n\n\nOverview\n\n\nIn this Tutorial\n\n\nWe will...\n\n\n\n\nAdd multiple nodes and sockets to objects\n\n\nCustomize the generation probability of plug objects\n\n\nUse jitter controls to create greater output variation\n\n\nUse node transform controls for refining plug object position, rotation, and scale\n\n\nCreate a basic runtime interface\n\n\nUse built-in Unity functions to pull usable information from our GameObjects\n\n\n\n\nObjectives\n\n\n\n\nWe want every generated tile to maintain a consistent visual style, but all generated tiles should look different.\n\n\nWe want a portion of the tiles to generate with ancient ruins.\n\n\nThe ruins, too, should be consistent but unique.\n\n\nWe want our game to easily recognize if the swamp tile contains ruins or not.\n\n\n\n\nApproach\n\n\nSmithy is unlike any built-in Unity tool, and requires a slightly different perspective on asset creation and management,\n  especially if Smithy is your first foray into procedural generation. We'll save ourselves a lot of time and effort with just a little planning.\n\n\nAn intuitive way to think about how Smithy handles assets is Lego, but backwards. If you buy a set, Lego supplies the pieces and the instructions.\n  Here, you supply the pieces and the instructions, and Smithy builds your set. Which is a roundabout way of saying that we have to consider \nhow\n assets will first\n  together.\n\n\nIn a real project you might start from a piece of concept artwork or artist's model, but because this is just a tutorial I've made a mockup from the \nactual assets we'll be using\n:\n\n\n\n\nThis is the kind of thing we're going for - swampy, half-submerged ruins. If we can consistently produce tiles like this, we'll consider our work a success. We just have to figure out\n  the best way to connect everything together. Smithy uses \nNodes\n that \nautomatically align and arrange their parent transforms\n. We define \nsockets\n, into which connect \nplugs\n. Let's explode this mockup to get a better idea of how our pieces connect together:\n\n\n\n\nWe can see here that our tiles are actually very straightforward and won't really require any complicated node structures.\n\n\n\n\nBranches connect to trees\n\n\nTrees, grass, ruins, and water connect to landscapes\n\n\nLandscapes connect to the tile base piece\n\n\n\n\nWe could have made the landscape and the base piece one model, but separating them gives us additional options - like generating landscapes without the base piece, which we'll talk about in the \nexpansion section\n.\n\n\nAnyway, we should now have a pretty good idea of how we'll need to lay out our nodes, so we can begin.\n\n\nWalkthrough\n\n\nSetup\n\n\nImport the Smithy Unity Package from your hard drive or directly from the Unity Asset store.\n\n\nTo quickly test that Smithy has loaded properly, press \nCTRL\n + \nALT\n + \nM\n to open the Manager window. If it opens properly, Smithy has installed correctly. If it throws an error, delete the \"Smithy\" folder and reinstall.\n\n\nThe assets for this walkthrough can be downloaded for free through the \nUnity Asset Store\n or \ndirectly\n. These assets are free to use, modify, and distribute (but not sell!) without attribution in any Unity project, Smithy-related or otherwise. Make sure these assets are located in a \nResources\n folder.\n\n\nBase Tile\n\n\nLet's start with our base and build upwards. This way, we can run test generations at each step of construction to make sure we're on the right track.\n\n\nImport the \nBase Tile\n prefab from the \nAssets/Resources/Swamp Tile/Meshes\n folder. The prefab will contain two meshes: \"Earth \n Rocks\" and \"Lava\". Assign matching materials in the \nAssets/Resources/Swamp Tile/Materials\n folder.\n\n\n\n\nIn the \nInspector\n tab, click \nAdd New Component\n and select \nSmithy\nAdd Smithy Adapter\n.\n\n\nThe \nadapter\n will be added with two critical warnings. Ignore them for now (we'll deal with them shortly) and click the teal \nNode Editor\n button. In the node editor panel, select \nAdd Node\n, \n (\nSocket Type\n), and \nMidpoint\n, like so:\n\n\n\n\nNow, in the \nScene Tab\n, hover over the middle of the tile base model. You'll see a magenta dot handle. Click once to add a node:\n\n\n\n\nThis is the \nsocket\n node the landscapes will \nplug\n in to. The \n icon marks it as a socket, and the little arrow is the \nconnection vector\n, which will tell Smithy how to orient the plug - in our case, straight \"down\" on to the flat top of our tile base. Imagine a physical socket whose walls are oriented straight upwards. You'd plug something in from above, straight down. That's what we've got here.\n\n\nSo, we have our socket. Now we need to tell Smithy what sort of socket it is.  \n\n\nReturn to the \nInspector Tab\n and look under the node palette to the layer list. \nLayer 0\n should be expanded, and contain a single node named \"(0.0, 3.0, 0.0)\", the socket we just placed. Click the \n icon to the right of the name and the gear icon.\n\n\nThe tag popup will appear. Click the \n+\n icon and enter \"Terrain\" into the form. Next, click the green checkmark button to add the Terrain tag to our Unity project. It should appear in the left-hand tag panel under \nAvailable Tags\n. Click it to move it to \nNode Tags\n. The process should look like this:\n\n\n\n\nWhat we've done is created a new tag, \"Terrain\", and assigned it to our Socket. This tells Smithy that the socket can accept Plugs that also carry the Terrain tag. However, there's nothing to plug in, because we don't have any \"Terrain\"-tagged Plugs. We don't have any plugs, period.\n\n\nLet's change that.\n\n\nClick the yellow \n+\n icon in the top-right corner of the Smithy Adapter component, and save the prefab to \nAssets/Resources/Finished\n.\n\n\nTerrain I\n\n\nDisable\n the tile base in the \nHierarchy Tab\n. This will let us work on the next piece more easily. Now add one of the terrain pieces in the \nAssets/Resources/Swamp Tile/Meshes/Terrains\n folder to the hierarchy. It doesn't matter which one, add whichever one looks good to you. Assign the \"Land\" Material to it.\n\n\nClick its GameObject in the Hierarchy Tab and add a Smithy Adapter by clicking \nAdd New Component\n and select \nSmithy\nAdd Smithy Adapter\n.\n\n\nIn the Smithy Adapter Inspector, navigate to the \nNode Editor\n tab and make sure the node palette is set to \nAdd Node\n, \n (\nPlug Type\n), and \nMidpoint\n.\n\n\nNow, hold down \nALT\n and click and drag in the Scene Tab to move the Scene View camera \nunder\n the terrain. Move the mouse to the diagonal line that bisects the bottom of the object, and click. If you've done everything right, you'll see the following:\n\n\n\n\nWe've added a plug node to the underside of the terrain, and we can see that the connection vector is angled straight down. Recall that our base piece's socket's connection vector is aligned straight up. When we generate pieces, terrains will be connected straight down to the base piece - exactly what we want.\n\n\nTo quickly check how Smithy will align an object during generation, set the node palette to \nEdit Node\n and use the \n (\nSelect\n) \nMode\n and click or hover over a node:\n\n\n\n\nThe wireframe box represents the direction, scale and orientation of the object, and the shaded face represents the object's facing \nin relation to the node\n. For this plug node, we can think of the shaded face as the prongs of the plug. Our plug node is oriented straight down, with no change to rotation and scale. It'll slot right in to our socket node.\n\n\nAll we have to do to finish this node is add the \"Terrain\" tag, so Smithy knows that this plug is available for the \"Terrain\"-tagged socket we placed on the base piece.\n\n\nFind the node in Layer 0 and click the \n button. The \"Terrain\" tag will already be in the Available Tags pane. Click it to add the tag to our plug node.\n\n\nFinally, click the yellow \n+\n icon in the top-right corner of the component, and save the prefab to \nAssets/Resources/Finished/Terrain\n.\n\n\nTest Generation I\n\n\nWe have a socket tagged \"Terrain\", and we have a plug tagged \"Terrain\". That's all we need to generate something in Smithy, so let's test it out and make sure we're on the right track.\n\n\nDouble-check that the terrain piece has been saved through Smithy, then disable it in the hierarchy. Return to the base piece, and re-enable it.\n\n\nIn the base piece's Smithy Adapter Inspector, click the orange \nAssembler\n button. Near the bottom of the panel, click either the blue \n (\nRun Generator\n) or purple \n (\nFill All\n) buttons. You should see the following:\n\n\n\n\nThe terrain should pop into existence right on top of our base piece. If it doesn't, double check that everything has been saved and is tagged appropriately.\n\n\nNow that we're sure we've got the basics working, we can begin decorating the terrain. Click the red \n (\nClear All\n) button to remove the generated terrain object.\n\n\nWater\n\n\nNow, before we continue, let's think about the best way to implement our water. It'd be cool to have varying water levels, and maybe even some tiles completely dry, but we don't really care \nwhich\n tiles generate with water and which ones don't - we want these to be built procedurally, after all - but water would be appropriate for all terrain pieces.\n\n\nWe \ncould\n attach a water socket to each terrain piece we make, but that's work we don't need to do. Instead, let's add it to the base piece.\n\n\nSocket\n\n\nThe best spot to add the water socket would be in the same place as the terrain socket. Smithy allows overlapping sockets, but overlapping sockets can get confusing in the editor, without a little effort. Let's start naming our sockets so we know what is what.\n\n\nIn the Smithy Adapter Inspector on the base piece, click the \n (\nNode Settings\n) button. The \nNode Settings Window\n will appear. Next to the plug symbol in the top left of the window is a small grey \n icon. Click this and change the name from \n(0.0, 3.0, 0.0)\n to \nTerrain\n.\n\n\n\n\nClick the green checkmark button on the bottom of the window to close it, and take a look at the node palette in the Adapter inspector. Make sure that the palette is set to  \nAdd Node\n, \n (\nSocket Type\n), and \nMidpoint\n.\n\n\nIn the Scene View tab, click on the \"Terrain\" node on the top of the base piece. The scene view won't change, but a new node named \n\"(0.0, 3.0, 0.0)\n will appear in the Layer 0 list.\n\n\nRepeat the renaming process and change the name of this new node to \n\"Water\"\n.\n\n\nClick the \n button and add a new tag: \"Water\". Then, click the \"Water\" tag in the Available Tags panel to add it to the node. The tag popup for the water socket should look like this:\n\n\n\n\nRecall that we want the water to be generated sometimes, but not all of the time. We can set that up pretty quickly.\n\n\nClick the blue \n button to the right of the node tag panel button. Use a \npreset\n or drag the slider to a percentage that seems suitable. For this tutorial, I've set the node to around 88%.\n\n\n\n\nThis means that the node will be filled 88% of the time. If we generate 10 tiles, we can expect about nine of them to be wet.\n\n\nNow, click the \ngreen\n \n icon in the top-right corner of the Adapter component to commit our changes to the prefab, and disable the base piece object in the hierarchy so we can work in a clean scene view.\n\n\nPlug\n\n\nIt's time to set up our water object. Head into the \nAssets/Resources/Swamp Tile/Meshes\n folder and put the Water model into the scene. Assign its material and add a Smithy Adapter component.\n\n\nExactly the same way we added the plug to the terrain, spin the Scene View camera around to the flat underside of the water object and \nAdd\n a \n (\nPlug\n) to the \nMidpoint\n of the diagonal that bisects the underside, like so:\n\n\n\n\nUse the tag panel to add the \"Water\" tag to this plug. Save the prefab to \nAssets/Resources/Finished/Terrain\n\n\nJitter\n\n\nOur generated tiles are going to look a lot less dynamic if tile that spawns with water has the same water level. To help with that, Smithy comes with jitter controls.\n\n\nJitter\n controls are random vectors applied to an object's position, rotation, and scale on generation. We can use a Y-scale jitter to stretch the water object's mesh, controlling our water level.\n\n\nOpen the \nNode Settings Window\n by clicking on the \n button next to the node's name (actually its position, right now). Scroll down to the jitter panel, which is marked with a purple \n icon.\n\n\nClick the \n button on the right side of the panel to add a new jitter control. Select \nScale Jitter (Vector)\n from the drop-up menu. This will let us isolate the Y-axis - a uniform jitter would scale in all dimensions equally.\n\n\n\n\nFor now, let's zero out the X- and Z-axis sliders. We only want to scale the Y-axis.\n\n\nDrag the X- and Z-axis sliders to the middle. This sets their minimum and maximum range to 0. Set the Y-axis slider to values you think would look good (we'll check in a second). Don't set the minimum value below zero here, though, that will invert our water mesh.\n\n\nI decided to set the Y-axis values to -0.98 and 0.71 respectively:\n\n\n\n\nWhen you're happy with your jitter range, click the green check mark to commit all changes to the node, then return to the Adapter inspector and click the green \n icon in the top-right corner. Go ahead and disable or delete the Water GameObject in the Hierarchy Tab.\n\n\nTest Generation II\n\n\nRe-enable the base piece in the Hierarchy. In the Adapter Inspector, click the orange \nAssembler\n tab. Click the blue \n (\nRun Generator\n) button a few times. Here's a sample of what you should see:\n\n\n\n\nYou should see the landscape being flooded most of the time, at varying water levels. Sometimes, however, they'll be no water at all. Here's what's happening:\n\n\n\n\nThe base piece is generating a landscape 100% of the time.\n\n\nThe base piece is (more or less) rolling some dice to see if it should generate a water object.\n\n\nIf so:\n\n\nthe water object is being scaled along the Y-axis, then...\n\n\nconnected to the socket on the base piece.\n\n\n\n\n\n\n\n\nClick the button a few more times to make sure it's looking good, and adjust the water socket generation probability and water plug's jitter values to taste.\n\n\nWhen you're done, click the red \n (\nClear All\n) button and disable the base piece in the Hierarchy Tab.\n\n\nTerrain II\n\n\nRe-enable or instantiate the Terrain piece from earlier.\n\n\nNow, click the blue \n+\n button at the bottom of the Adapter inspector to add a new node layer to this adapter.\n\n\nA new layer, titled \nLayer 1\n will appear under Layer 0. You'll notice that Layer 0 has turned dark blue, and Layer 1 is now teal. This means that Layer 1 is the \nactive layer\n. If we add any nodes now, they'll get placed in Layer 1. To switch active layers, click the layer's name (but don't do that now).\n\n\nClick the light blue \n icon to the right of Layer 1. This opens the Layer Settings Window.\n\n\nYou'll see that there are no nodes present in the layer right now. That's fine, we'll get to that shortly. For now, click the grey \n to change the layer's name (just like the Node Settings Window) from \"Layer 1\" to \n\"Grass\"\n, then commit the changes to the Adapter and close the window. Your layer list should look like this:\n\n\n\n\nGo to the Node Palette and set \nAdd\n a \n (\nSocket\n) and \nOff\n. Ensure that the new \"Grass\" layer is active.\n\n\nNow, in the Scene View Tab, add a handful of nodes where you'd like grass to grow:\n\n\n\n\nI ended up adding 16 grass nodes. You can add as many as you like -- because grass won't have a sub-object hierarchy, we don't really have to worry about adding generational complexity. If the big list of nodes in the inspector bothers you, click the caret to collapse the node list. We actually won't be touching the nodes individually. Instead we'll set up everything at once using the Layer Settings Window.\n\n\nGrass Layer Settings\n\n\nClick the blue \n+\n grass layer settings button again. You'll notice that now, the window has been populated with all of the nodes we just added:\n\n\n\n\nClick the blue \nSelect All\n button in the lower left side to select all of our grass sockets. You'll notice immediately that the right column of the window turns into a control panel very similar to the Node Settings Window.\n\n\nThe first row of X/Y/Z values will change the position of the node. Set the Y-value to -0.05 and click the green check mark to move all selected nodes by this value.\n\n\nWhy? Well because we want our grass models to look like they're part of the scene, and we'll be putting our plug nodes right on the bottom of the grass mesh. If we kept the nodes on the surface of our Terrain piece, they'd look like they were almost floating - just \nbaaarely\n touching the ground. It'd look weird. Getting them down in the ground just a little bit will look way more natural.\n\n\nClose (or move aside) the Layer Window. Your terrain piece should look like this:\n\n\n\n\nThe node icons are transparent because they're within the object mesh. This is what we want.\n\n\nYou might have noticed, when placing nodes, that the node's \nconnection vectors\n are reflections of the normal the node is placed against. Most of the time, this is what you want -- flat surfaces will sit flush with each other. However, we're laying the sockets for grass. Grass grows towards the sun, and if our grass is growing everywhere at odd angles it's going to look like fur or something, not grass. We need these connection vectors to be oriented straight up.\n\n\nOpen up the Layer Settings Window again, if you've closed it. \nSelect All\n once again.\n\n\nThe fourth row down, the \n icon, will quick-set all connection vectors. Click the first button, the \n button, which sets all connection vectors to \nworld up\n.\n\n\nJust below that in the layer window is the probability selector. Press the blue \n (\nUncommon\n) button. This will prevent all of our grasses from spawning every time, making the finished tiles look far more organic. The Uncommon setting is set to 60% by default, but this can be changed in the \nprobability preset manager\n.\n\n\nBelow probability is the Tag panel. Like before, click the \n+\n button and add the tag \"Grass\". Click the new tag in the Available Tags column to add it to all of the selected nodes.\n\n\nFinally, we're going to mass-add jitter values. The Jitter panel is below the tag panel. Click the \n button to add a \nRotation Jitter\n, and again to add a \nVector Scale Jitter\n\n\nWe only want the grass to be able to rotate around their Y-axes, but we don't need any limits on how much they can rotate. In the Rotation Jitter control, zero out the X- and Z- axes, and max out (-180 to 180) the Y axis.\n\n\nIn the Vector Scale Jitter control, set all axes to a similar, small value to add a little variation to how our grass will grow. I chose -0.30 and 0.30, for each axis.\n\n\n\n\nClick the purple \n button to copy this jitter control to all selected nodes. Exit the menu, and save changes in the adapter inspector. Disable the terrain in the hierarchy so we have an empty scene view to work in.\n\n\nGrass\n\n\nGo to the \nAssets/Resources/Swamp Tile/Meshes/Grass\n folder and drag \"Grass A\" into the heirarchy. Apply the \"Moss\" material. Add a Smithy Adapter component.\n\n\nIn the Node Editor tab, make sure that the palette is set to \n\"Add Node\"\n and \n\"Plug\"\n. Instead of adding a node through the viewport, click the \n+\n button to add a new, unanchored node. The node should appear at (0,0,0) like so:\n\n\n\n\nNow, switch the node palette to \nEdit Node\n / \nSelect\n mode, and click the node in the Scene View. It'll turn bright green. You'll notice the connection vector is pointed directly up - we don't want this. Our grasses will instantiate upside down.\n\n\nTo fix this, click the final palette option, the \n (\nAdjust Connection Vector\n) button.\n\n\nNow, click the downward arrow in the snap menu to set the connection vector to \nworld down\n. You should see this:\n\n\n\n\nAdd the \"Grass\" tag to the node, using the \n button.\n\n\nCopying Adapters\n\n\nDon't delete or disable the grass GameObject in the hierarchy. Instead, select and drag all of the remaining grasses from the \nMeshes/Grass\n folder into the hierarchy, and assign the Moss material to them. You can do this easily by selecting all of the grasses in the Hierarchy Tab and dragging the Moss material into the Inspector Tab.\n\n\nNow, select only \"Grass A\", the one with the Smithy Adapter on it. Right click on the very top of the Smithy Adapter Inspector and click \n\"Copy Component\"\n:\n\n\n\n\nGroup select the \nother\n grass objects (grasses B through F). Right-click on the Transform component and select \nPaste Component As New\"\n:\n\n\n\n\nThis will copy the Smithy adapter, along with our plug node, to each Grass object. This saved us a bunch of time, and is something to definitely remember whenever preparing a bunch of assets that are going to be handled the same way.\n\n\nSave \neach\n grass object to prefab, through the Smithy adapter, then remove them from the heirarchy.\n\n\nTest Generation III\n\n\nGo back to the base piece and run the Assembler generator a few times:\n\n\n\n\nIf everything looks good, click the red \n (\nClear All\n) button and disable the base piece.\n\n\nTrees\n\n\nSockets\n\n\nWe're going to repeat the grass process with the trees.\n\n\nActivate Terrain A in the hierarchy and add a new node layer, named \"Trees\". Add a few socket nodes, wherever you think is suitable (Click the \n button on the inactive layer to hide the other layers and reduce visual clutter). These trees have pretty wide root systems, though, so it's best to keep them away from the edges.\n\n\n\n\nNow, select all of these sockets in their layer window. Use the techniques we've covered in the last several steps to do the following:\n\n\n\n\nAdd a Y-axis position offset like we did with the grass, but decrease the value to -0.1\n\n\nSet all connection vectors to \nworld up\n by clicking the upwards-facing arrow in the connection vector settings panel\n\n\nCreate a new tag, \"Tree\", and add it to the sockets\n\n\nSet the probability to \n (\nRare\n)\n\n\nApply a Y-axis rotation jitter control with limits at -180 degrees and +180 degrees.\n\n\nClose the Layer Settings Window and save through the adapter.\n\n\n\n\nPlugs\n\n\nAgain, like with the grass, we're going to batch all of our tree objects by defining the plug node on one tree and copying the adapter to the other trees.\n\n\nPull all of the tree meshes from the \nMeshes/Trees\n folder into the hierarchy. Apply the \"Wood\" material to them.\n\n\nNow, select Tree A, and:\n\n\n\n\nAdd a new unanchored node with the \n+\n button\n\n\nSelect the node through the palette's \nEdit Node\n / \nSelect\n mode.\n\n\nClick the downward-facing arrow in the \n (\nAdjust Connection Vector\n) snap menu to set the connection vector to \nworld down\n\n\nUse the Tag Panel to add the \"Tree\" tag to the node.\n\n\nRight-click on the Smithy Adapter inspector title and select \"Copy Component\"\n\n\nShift-select and paste the component to the rest of the tree objects.\n\n\n\n\nSave each of the trees through the Smithy adapter to the \nFinished\n folder. Remove them from the hierarchy, and check your work by using the Assembler generator on the base piece. It should generate something like this:\n\n\n\n\nIf it looks a little off, don't worry. We'll take a final pass near the end and tweak everything to get it perfect. For now, make sure that trees don't have roots hanging off of the edge. If they do, go back into the Terrain A Tree nodes and move them towards the center.\n\n\nBranches\n\n\n[[[CHANGE THIS -- ALIGN ALL BASES WITH y 0]]]\n\n\nThis part, unfortunately, can't be batched. The good news is that there are only four, and they'll add a ton of variety.\n\n\nGo into the \nMeshes/Trees/Branches\n folder and grab \"Branch A\". Assign the \"Wood\" material and add a Smithy Adapter.\n\n\nRotate the branch so you can see the base. You'll notice the branch seems to \"clip out\" back here because there's no geometry in that area. This is fine, because we're going to manually position the plug node.\n\n\nEnter edit mode and keep the palette at default settings. Click one of the vertices near the base of the branch:\n\n\n\n\nNeither the position nor the connection vector of the node is what we want. Let's change that.\n\n\nEnter the \nEdit Node\n mode from the palette and click the node in the Scene View to select it.\n\n\nNow, click the \n button in the palette. In the Scene view, manipulate the movement handles to position the node roughly in the middle of the branch's base. Then, inset the node just a little into the body of the branch, like so:\n\n\n\n\nFinally, click the button labeled \"C\" (\n\"Align to Object Center\"\n) arrow in the \n (\nAdjust Connection Vector\n) snap menu. You might also want to tweak the connection vector manually, depending on how you positioned the node. In the end, the vector should look like this:\n\n\n\n\nAdd a new tag, \"Branch\", and save this branch as a prefab through the Smithy Adapter.\n\n\nNow, repeat this process for the rest of the branches in the \nMeshes/Trees/Branches\n folder.", 
            "title": "Strategy Game Tile"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#strategy-game-tile-tutorial", 
            "text": "", 
            "title": "Strategy Game Tile Tutorial"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#live-demo", 
            "text": "", 
            "title": "Live Demo"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#introduction", 
            "text": "In this tutorial we'll be using Smithy to procedurally generate swampland tiles for a strategy game.  If you haven't yet, I recommend checking out the  Quick Start Tutorial  first. This tutorial builds off of some of the basics covered in the quick start.", 
            "title": "Introduction"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#in-this-tutorial", 
            "text": "We will...   Add multiple nodes and sockets to objects  Customize the generation probability of plug objects  Use jitter controls to create greater output variation  Use node transform controls for refining plug object position, rotation, and scale  Create a basic runtime interface  Use built-in Unity functions to pull usable information from our GameObjects", 
            "title": "In this Tutorial"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#objectives", 
            "text": "We want every generated tile to maintain a consistent visual style, but all generated tiles should look different.  We want a portion of the tiles to generate with ancient ruins.  The ruins, too, should be consistent but unique.  We want our game to easily recognize if the swamp tile contains ruins or not.", 
            "title": "Objectives"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#approach", 
            "text": "Smithy is unlike any built-in Unity tool, and requires a slightly different perspective on asset creation and management,\n  especially if Smithy is your first foray into procedural generation. We'll save ourselves a lot of time and effort with just a little planning.  An intuitive way to think about how Smithy handles assets is Lego, but backwards. If you buy a set, Lego supplies the pieces and the instructions.\n  Here, you supply the pieces and the instructions, and Smithy builds your set. Which is a roundabout way of saying that we have to consider  how  assets will first\n  together.  In a real project you might start from a piece of concept artwork or artist's model, but because this is just a tutorial I've made a mockup from the  actual assets we'll be using :   This is the kind of thing we're going for - swampy, half-submerged ruins. If we can consistently produce tiles like this, we'll consider our work a success. We just have to figure out\n  the best way to connect everything together. Smithy uses  Nodes  that  automatically align and arrange their parent transforms . We define  sockets , into which connect  plugs . Let's explode this mockup to get a better idea of how our pieces connect together:   We can see here that our tiles are actually very straightforward and won't really require any complicated node structures.   Branches connect to trees  Trees, grass, ruins, and water connect to landscapes  Landscapes connect to the tile base piece   We could have made the landscape and the base piece one model, but separating them gives us additional options - like generating landscapes without the base piece, which we'll talk about in the  expansion section .  Anyway, we should now have a pretty good idea of how we'll need to lay out our nodes, so we can begin.", 
            "title": "Approach"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#walkthrough", 
            "text": "", 
            "title": "Walkthrough"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#setup", 
            "text": "Import the Smithy Unity Package from your hard drive or directly from the Unity Asset store.  To quickly test that Smithy has loaded properly, press  CTRL  +  ALT  +  M  to open the Manager window. If it opens properly, Smithy has installed correctly. If it throws an error, delete the \"Smithy\" folder and reinstall.  The assets for this walkthrough can be downloaded for free through the  Unity Asset Store  or  directly . These assets are free to use, modify, and distribute (but not sell!) without attribution in any Unity project, Smithy-related or otherwise. Make sure these assets are located in a  Resources  folder.", 
            "title": "Setup"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#base-tile", 
            "text": "Let's start with our base and build upwards. This way, we can run test generations at each step of construction to make sure we're on the right track.  Import the  Base Tile  prefab from the  Assets/Resources/Swamp Tile/Meshes  folder. The prefab will contain two meshes: \"Earth   Rocks\" and \"Lava\". Assign matching materials in the  Assets/Resources/Swamp Tile/Materials  folder.   In the  Inspector  tab, click  Add New Component  and select  Smithy Add Smithy Adapter .  The  adapter  will be added with two critical warnings. Ignore them for now (we'll deal with them shortly) and click the teal  Node Editor  button. In the node editor panel, select  Add Node ,   ( Socket Type ), and  Midpoint , like so:   Now, in the  Scene Tab , hover over the middle of the tile base model. You'll see a magenta dot handle. Click once to add a node:   This is the  socket  node the landscapes will  plug  in to. The   icon marks it as a socket, and the little arrow is the  connection vector , which will tell Smithy how to orient the plug - in our case, straight \"down\" on to the flat top of our tile base. Imagine a physical socket whose walls are oriented straight upwards. You'd plug something in from above, straight down. That's what we've got here.  So, we have our socket. Now we need to tell Smithy what sort of socket it is.    Return to the  Inspector Tab  and look under the node palette to the layer list.  Layer 0  should be expanded, and contain a single node named \"(0.0, 3.0, 0.0)\", the socket we just placed. Click the   icon to the right of the name and the gear icon.  The tag popup will appear. Click the  +  icon and enter \"Terrain\" into the form. Next, click the green checkmark button to add the Terrain tag to our Unity project. It should appear in the left-hand tag panel under  Available Tags . Click it to move it to  Node Tags . The process should look like this:   What we've done is created a new tag, \"Terrain\", and assigned it to our Socket. This tells Smithy that the socket can accept Plugs that also carry the Terrain tag. However, there's nothing to plug in, because we don't have any \"Terrain\"-tagged Plugs. We don't have any plugs, period.  Let's change that.  Click the yellow  +  icon in the top-right corner of the Smithy Adapter component, and save the prefab to  Assets/Resources/Finished .", 
            "title": "Base Tile"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#terrain-i", 
            "text": "Disable  the tile base in the  Hierarchy Tab . This will let us work on the next piece more easily. Now add one of the terrain pieces in the  Assets/Resources/Swamp Tile/Meshes/Terrains  folder to the hierarchy. It doesn't matter which one, add whichever one looks good to you. Assign the \"Land\" Material to it.  Click its GameObject in the Hierarchy Tab and add a Smithy Adapter by clicking  Add New Component  and select  Smithy Add Smithy Adapter .  In the Smithy Adapter Inspector, navigate to the  Node Editor  tab and make sure the node palette is set to  Add Node ,   ( Plug Type ), and  Midpoint .  Now, hold down  ALT  and click and drag in the Scene Tab to move the Scene View camera  under  the terrain. Move the mouse to the diagonal line that bisects the bottom of the object, and click. If you've done everything right, you'll see the following:   We've added a plug node to the underside of the terrain, and we can see that the connection vector is angled straight down. Recall that our base piece's socket's connection vector is aligned straight up. When we generate pieces, terrains will be connected straight down to the base piece - exactly what we want.  To quickly check how Smithy will align an object during generation, set the node palette to  Edit Node  and use the   ( Select )  Mode  and click or hover over a node:   The wireframe box represents the direction, scale and orientation of the object, and the shaded face represents the object's facing  in relation to the node . For this plug node, we can think of the shaded face as the prongs of the plug. Our plug node is oriented straight down, with no change to rotation and scale. It'll slot right in to our socket node.  All we have to do to finish this node is add the \"Terrain\" tag, so Smithy knows that this plug is available for the \"Terrain\"-tagged socket we placed on the base piece.  Find the node in Layer 0 and click the   button. The \"Terrain\" tag will already be in the Available Tags pane. Click it to add the tag to our plug node.  Finally, click the yellow  +  icon in the top-right corner of the component, and save the prefab to  Assets/Resources/Finished/Terrain .", 
            "title": "Terrain I"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#test-generation-i", 
            "text": "We have a socket tagged \"Terrain\", and we have a plug tagged \"Terrain\". That's all we need to generate something in Smithy, so let's test it out and make sure we're on the right track.  Double-check that the terrain piece has been saved through Smithy, then disable it in the hierarchy. Return to the base piece, and re-enable it.  In the base piece's Smithy Adapter Inspector, click the orange  Assembler  button. Near the bottom of the panel, click either the blue   ( Run Generator ) or purple   ( Fill All ) buttons. You should see the following:   The terrain should pop into existence right on top of our base piece. If it doesn't, double check that everything has been saved and is tagged appropriately.  Now that we're sure we've got the basics working, we can begin decorating the terrain. Click the red   ( Clear All ) button to remove the generated terrain object.", 
            "title": "Test Generation I"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#water", 
            "text": "Now, before we continue, let's think about the best way to implement our water. It'd be cool to have varying water levels, and maybe even some tiles completely dry, but we don't really care  which  tiles generate with water and which ones don't - we want these to be built procedurally, after all - but water would be appropriate for all terrain pieces.  We  could  attach a water socket to each terrain piece we make, but that's work we don't need to do. Instead, let's add it to the base piece.", 
            "title": "Water"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#socket", 
            "text": "The best spot to add the water socket would be in the same place as the terrain socket. Smithy allows overlapping sockets, but overlapping sockets can get confusing in the editor, without a little effort. Let's start naming our sockets so we know what is what.  In the Smithy Adapter Inspector on the base piece, click the   ( Node Settings ) button. The  Node Settings Window  will appear. Next to the plug symbol in the top left of the window is a small grey   icon. Click this and change the name from  (0.0, 3.0, 0.0)  to  Terrain .   Click the green checkmark button on the bottom of the window to close it, and take a look at the node palette in the Adapter inspector. Make sure that the palette is set to   Add Node ,   ( Socket Type ), and  Midpoint .  In the Scene View tab, click on the \"Terrain\" node on the top of the base piece. The scene view won't change, but a new node named  \"(0.0, 3.0, 0.0)  will appear in the Layer 0 list.  Repeat the renaming process and change the name of this new node to  \"Water\" .  Click the   button and add a new tag: \"Water\". Then, click the \"Water\" tag in the Available Tags panel to add it to the node. The tag popup for the water socket should look like this:   Recall that we want the water to be generated sometimes, but not all of the time. We can set that up pretty quickly.  Click the blue   button to the right of the node tag panel button. Use a  preset  or drag the slider to a percentage that seems suitable. For this tutorial, I've set the node to around 88%.   This means that the node will be filled 88% of the time. If we generate 10 tiles, we can expect about nine of them to be wet.  Now, click the  green    icon in the top-right corner of the Adapter component to commit our changes to the prefab, and disable the base piece object in the hierarchy so we can work in a clean scene view.", 
            "title": "Socket"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#plug", 
            "text": "It's time to set up our water object. Head into the  Assets/Resources/Swamp Tile/Meshes  folder and put the Water model into the scene. Assign its material and add a Smithy Adapter component.  Exactly the same way we added the plug to the terrain, spin the Scene View camera around to the flat underside of the water object and  Add  a   ( Plug ) to the  Midpoint  of the diagonal that bisects the underside, like so:   Use the tag panel to add the \"Water\" tag to this plug. Save the prefab to  Assets/Resources/Finished/Terrain", 
            "title": "Plug"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#jitter", 
            "text": "Our generated tiles are going to look a lot less dynamic if tile that spawns with water has the same water level. To help with that, Smithy comes with jitter controls.  Jitter  controls are random vectors applied to an object's position, rotation, and scale on generation. We can use a Y-scale jitter to stretch the water object's mesh, controlling our water level.  Open the  Node Settings Window  by clicking on the   button next to the node's name (actually its position, right now). Scroll down to the jitter panel, which is marked with a purple   icon.  Click the   button on the right side of the panel to add a new jitter control. Select  Scale Jitter (Vector)  from the drop-up menu. This will let us isolate the Y-axis - a uniform jitter would scale in all dimensions equally.   For now, let's zero out the X- and Z-axis sliders. We only want to scale the Y-axis.  Drag the X- and Z-axis sliders to the middle. This sets their minimum and maximum range to 0. Set the Y-axis slider to values you think would look good (we'll check in a second). Don't set the minimum value below zero here, though, that will invert our water mesh.  I decided to set the Y-axis values to -0.98 and 0.71 respectively:   When you're happy with your jitter range, click the green check mark to commit all changes to the node, then return to the Adapter inspector and click the green   icon in the top-right corner. Go ahead and disable or delete the Water GameObject in the Hierarchy Tab.", 
            "title": "Jitter"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#test-generation-ii", 
            "text": "Re-enable the base piece in the Hierarchy. In the Adapter Inspector, click the orange  Assembler  tab. Click the blue   ( Run Generator ) button a few times. Here's a sample of what you should see:   You should see the landscape being flooded most of the time, at varying water levels. Sometimes, however, they'll be no water at all. Here's what's happening:   The base piece is generating a landscape 100% of the time.  The base piece is (more or less) rolling some dice to see if it should generate a water object.  If so:  the water object is being scaled along the Y-axis, then...  connected to the socket on the base piece.     Click the button a few more times to make sure it's looking good, and adjust the water socket generation probability and water plug's jitter values to taste.  When you're done, click the red   ( Clear All ) button and disable the base piece in the Hierarchy Tab.", 
            "title": "Test Generation II"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#terrain-ii", 
            "text": "Re-enable or instantiate the Terrain piece from earlier.  Now, click the blue  +  button at the bottom of the Adapter inspector to add a new node layer to this adapter.  A new layer, titled  Layer 1  will appear under Layer 0. You'll notice that Layer 0 has turned dark blue, and Layer 1 is now teal. This means that Layer 1 is the  active layer . If we add any nodes now, they'll get placed in Layer 1. To switch active layers, click the layer's name (but don't do that now).  Click the light blue   icon to the right of Layer 1. This opens the Layer Settings Window.  You'll see that there are no nodes present in the layer right now. That's fine, we'll get to that shortly. For now, click the grey   to change the layer's name (just like the Node Settings Window) from \"Layer 1\" to  \"Grass\" , then commit the changes to the Adapter and close the window. Your layer list should look like this:   Go to the Node Palette and set  Add  a   ( Socket ) and  Off . Ensure that the new \"Grass\" layer is active.  Now, in the Scene View Tab, add a handful of nodes where you'd like grass to grow:   I ended up adding 16 grass nodes. You can add as many as you like -- because grass won't have a sub-object hierarchy, we don't really have to worry about adding generational complexity. If the big list of nodes in the inspector bothers you, click the caret to collapse the node list. We actually won't be touching the nodes individually. Instead we'll set up everything at once using the Layer Settings Window.", 
            "title": "Terrain II"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#grass-layer-settings", 
            "text": "Click the blue  +  grass layer settings button again. You'll notice that now, the window has been populated with all of the nodes we just added:   Click the blue  Select All  button in the lower left side to select all of our grass sockets. You'll notice immediately that the right column of the window turns into a control panel very similar to the Node Settings Window.  The first row of X/Y/Z values will change the position of the node. Set the Y-value to -0.05 and click the green check mark to move all selected nodes by this value.  Why? Well because we want our grass models to look like they're part of the scene, and we'll be putting our plug nodes right on the bottom of the grass mesh. If we kept the nodes on the surface of our Terrain piece, they'd look like they were almost floating - just  baaarely  touching the ground. It'd look weird. Getting them down in the ground just a little bit will look way more natural.  Close (or move aside) the Layer Window. Your terrain piece should look like this:   The node icons are transparent because they're within the object mesh. This is what we want.  You might have noticed, when placing nodes, that the node's  connection vectors  are reflections of the normal the node is placed against. Most of the time, this is what you want -- flat surfaces will sit flush with each other. However, we're laying the sockets for grass. Grass grows towards the sun, and if our grass is growing everywhere at odd angles it's going to look like fur or something, not grass. We need these connection vectors to be oriented straight up.  Open up the Layer Settings Window again, if you've closed it.  Select All  once again.  The fourth row down, the   icon, will quick-set all connection vectors. Click the first button, the   button, which sets all connection vectors to  world up .  Just below that in the layer window is the probability selector. Press the blue   ( Uncommon ) button. This will prevent all of our grasses from spawning every time, making the finished tiles look far more organic. The Uncommon setting is set to 60% by default, but this can be changed in the  probability preset manager .  Below probability is the Tag panel. Like before, click the  +  button and add the tag \"Grass\". Click the new tag in the Available Tags column to add it to all of the selected nodes.  Finally, we're going to mass-add jitter values. The Jitter panel is below the tag panel. Click the   button to add a  Rotation Jitter , and again to add a  Vector Scale Jitter  We only want the grass to be able to rotate around their Y-axes, but we don't need any limits on how much they can rotate. In the Rotation Jitter control, zero out the X- and Z- axes, and max out (-180 to 180) the Y axis.  In the Vector Scale Jitter control, set all axes to a similar, small value to add a little variation to how our grass will grow. I chose -0.30 and 0.30, for each axis.   Click the purple   button to copy this jitter control to all selected nodes. Exit the menu, and save changes in the adapter inspector. Disable the terrain in the hierarchy so we have an empty scene view to work in.", 
            "title": "Grass Layer Settings"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#grass", 
            "text": "Go to the  Assets/Resources/Swamp Tile/Meshes/Grass  folder and drag \"Grass A\" into the heirarchy. Apply the \"Moss\" material. Add a Smithy Adapter component.  In the Node Editor tab, make sure that the palette is set to  \"Add Node\"  and  \"Plug\" . Instead of adding a node through the viewport, click the  +  button to add a new, unanchored node. The node should appear at (0,0,0) like so:   Now, switch the node palette to  Edit Node  /  Select  mode, and click the node in the Scene View. It'll turn bright green. You'll notice the connection vector is pointed directly up - we don't want this. Our grasses will instantiate upside down.  To fix this, click the final palette option, the   ( Adjust Connection Vector ) button.  Now, click the downward arrow in the snap menu to set the connection vector to  world down . You should see this:   Add the \"Grass\" tag to the node, using the   button.", 
            "title": "Grass"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#copying-adapters", 
            "text": "Don't delete or disable the grass GameObject in the hierarchy. Instead, select and drag all of the remaining grasses from the  Meshes/Grass  folder into the hierarchy, and assign the Moss material to them. You can do this easily by selecting all of the grasses in the Hierarchy Tab and dragging the Moss material into the Inspector Tab.  Now, select only \"Grass A\", the one with the Smithy Adapter on it. Right click on the very top of the Smithy Adapter Inspector and click  \"Copy Component\" :   Group select the  other  grass objects (grasses B through F). Right-click on the Transform component and select  Paste Component As New\" :   This will copy the Smithy adapter, along with our plug node, to each Grass object. This saved us a bunch of time, and is something to definitely remember whenever preparing a bunch of assets that are going to be handled the same way.  Save  each  grass object to prefab, through the Smithy adapter, then remove them from the heirarchy.", 
            "title": "Copying Adapters"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#test-generation-iii", 
            "text": "Go back to the base piece and run the Assembler generator a few times:   If everything looks good, click the red   ( Clear All ) button and disable the base piece.", 
            "title": "Test Generation III"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#trees", 
            "text": "", 
            "title": "Trees"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#sockets", 
            "text": "We're going to repeat the grass process with the trees.  Activate Terrain A in the hierarchy and add a new node layer, named \"Trees\". Add a few socket nodes, wherever you think is suitable (Click the   button on the inactive layer to hide the other layers and reduce visual clutter). These trees have pretty wide root systems, though, so it's best to keep them away from the edges.   Now, select all of these sockets in their layer window. Use the techniques we've covered in the last several steps to do the following:   Add a Y-axis position offset like we did with the grass, but decrease the value to -0.1  Set all connection vectors to  world up  by clicking the upwards-facing arrow in the connection vector settings panel  Create a new tag, \"Tree\", and add it to the sockets  Set the probability to   ( Rare )  Apply a Y-axis rotation jitter control with limits at -180 degrees and +180 degrees.  Close the Layer Settings Window and save through the adapter.", 
            "title": "Sockets"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#plugs", 
            "text": "Again, like with the grass, we're going to batch all of our tree objects by defining the plug node on one tree and copying the adapter to the other trees.  Pull all of the tree meshes from the  Meshes/Trees  folder into the hierarchy. Apply the \"Wood\" material to them.  Now, select Tree A, and:   Add a new unanchored node with the  +  button  Select the node through the palette's  Edit Node  /  Select  mode.  Click the downward-facing arrow in the   ( Adjust Connection Vector ) snap menu to set the connection vector to  world down  Use the Tag Panel to add the \"Tree\" tag to the node.  Right-click on the Smithy Adapter inspector title and select \"Copy Component\"  Shift-select and paste the component to the rest of the tree objects.   Save each of the trees through the Smithy adapter to the  Finished  folder. Remove them from the hierarchy, and check your work by using the Assembler generator on the base piece. It should generate something like this:   If it looks a little off, don't worry. We'll take a final pass near the end and tweak everything to get it perfect. For now, make sure that trees don't have roots hanging off of the edge. If they do, go back into the Terrain A Tree nodes and move them towards the center.", 
            "title": "Plugs"
        }, 
        {
            "location": "/demos_tutorials/swamp_tile/#branches", 
            "text": "[[[CHANGE THIS -- ALIGN ALL BASES WITH y 0]]]  This part, unfortunately, can't be batched. The good news is that there are only four, and they'll add a ton of variety.  Go into the  Meshes/Trees/Branches  folder and grab \"Branch A\". Assign the \"Wood\" material and add a Smithy Adapter.  Rotate the branch so you can see the base. You'll notice the branch seems to \"clip out\" back here because there's no geometry in that area. This is fine, because we're going to manually position the plug node.  Enter edit mode and keep the palette at default settings. Click one of the vertices near the base of the branch:   Neither the position nor the connection vector of the node is what we want. Let's change that.  Enter the  Edit Node  mode from the palette and click the node in the Scene View to select it.  Now, click the   button in the palette. In the Scene view, manipulate the movement handles to position the node roughly in the middle of the branch's base. Then, inset the node just a little into the body of the branch, like so:   Finally, click the button labeled \"C\" ( \"Align to Object Center\" ) arrow in the   ( Adjust Connection Vector ) snap menu. You might also want to tweak the connection vector manually, depending on how you positioned the node. In the end, the vector should look like this:   Add a new tag, \"Branch\", and save this branch as a prefab through the Smithy Adapter.  Now, repeat this process for the rest of the branches in the  Meshes/Trees/Branches  folder.", 
            "title": "Branches"
        }, 
        {
            "location": "/demos_tutorials/fps_arsenal/", 
            "text": "", 
            "title": "FPS Arsenal"
        }, 
        {
            "location": "/demos_tutorials/rpg_hero/", 
            "text": "", 
            "title": "RPG Hero"
        }, 
        {
            "location": "/editor/adapter/", 
            "text": "Overview\n\n\nSmithy Adapters are \nComponents\n that contain \nNodes\n, and are required for \nprocedurally generating objects\n.\n\n\nAdapters are added by clicking \nAdd Component\n in the GameObject inspector, and selecting \nSmithy\n \n \nAdd Smithy Adapter\n\n\n\n  \n\n  Please note that Smithy can only load and instantiate Prefabs that are located in the \n/Assets/Resources\n folder of your Project, or \nAsset Bundles\n that have already been loaded.\n  \n\n  \n\n\nInspector\n\n\nAdapters are equipped with a custom inspector, which is the principal point of access for working with \nNodes\n. Once a Smithy Adapter component is added to a GameObject, it will appear in that GameObject's component inspector.\n\n\nVery narrow inspector layouts may make some UI components overlap. If this is the case, widen the inspector window to a comfortable width.\n\n\nNavigation\n\n\n\n\nThe Navigation panel accesses the Information Panel, the Node Editor, and the Object Assembler.\n  The Node Editor and Object Assembler are only available when the GameObject is active in the hierarchy. If the GameObject is saved as a prefab, these options will be disabled.\n\n\nSaving\n\n\nSmithy uses asset labels and prefab assets during procedural generation. Therefore, GameObjects must be saved as prefabs before they can be used by Smithy.\n\n\nCorrectly saved and labeled prefabs are crucial to Smithy's operation, so each Adapter is able to manage the saving of it's linked prefab. Simply activate the autosave in the save menu once a prefab has been linked.\n\n\n\n  \n\n  For best results, let Smithy manage the saving and updating of prefabs with that have Smithy Adapters. Smithy will ensure that these prefabs are labeled correctly prior to building, and useable in generation. Manually saving and updating Smithy prefabs is not recommended - it may work, but can't be guaranteed.\n\n  \n\n  \n\n\n\n\nThe top right corner of the navigation panel contains the Save indicator. The icon changes based on state:\n\n\n\n\n\n\n\n\nIndicator\n\n\nStatus\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\nUnsaved\n(no prefab)\n\n\nThis GameObject has not been saved as a prefab. Clicking this icon will allow you to save the GameObject and create a prefab connection.\n\n\n\n\n\n\n\n\nUnsaved\n\n\nThis GameObject has a prefab connection but has unsaved changes. Clicking this icon will save changes to the prefab, or, allow you to activate Smithy's autosave feature.\n\n\n\n\n\n\n\n\nSaving\n\n\nThis GameObject is currently saving any changes. This should only take a brief moment, but allow it to save before starting a build or entering Game mode.\n\n\n\n\n\n\n\n\nPrefab OK\n \n(autosave off)\n\n\nThis GameObject has a prefab connection that is current with any changes made. Autosave is not on and the GameObject will need to be saved manually. Click to \nactivate\n autosave.\n\n\n\n\n\n\n\n\nPrefab OK\n \n(autosave on)\n\n\nThis GameObject has a prefab connection that is current with any changes made. Autosave is on. Click to \ndeactivate\n autosave.\n\n\n\n\n\n\n\n\n\n\nInformation Panel\n\n\n\n  The information panel is the first navigation panel option and provides an at-a-glance display of all critical Node information. The information panel is comprised of a warning panel, a generation depth counter, and a tag list panel.  \n\n\nWarning Panel\n\n\nThe warning panel will display any issues that might affect the operation of this adapter or its nodes. It has two states:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \nValid\n\n\n \nProblems Detected\n(where # is the number of issues)\n\n\n\n\n\n\n\n\nIssues that Smithy detects are arranged into three categories:\n\n\n\n\n\n\n\n\nWarning\n\n\nImportant\n\n\nCritical\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThese will not cause problems with generation, but may potentially produce undesirable results\n\n\nThese issues are will generate poor or unexpected results, but will not cause errors\n\n\nThis issues are serious and will throw errors or prevent any Nodes on this adapter from being detected.\n\n\n\n\n\n\n\n\nAlt-clicking the warning icon will open the relevant \ntroubleshooting\n link in a new browser window.\n\n\nGeneration Depth Panel\n\n\nDisplays the \nmaximum generation depth\n for this adapter.\n\n\nTag List Panel\n\n\nDisplays a list of all Tags present on the Adapter's nodes. Tags present on Plugs will be shown in \nblue\n, and Tags present on Sockets will be shown in \nteal\n.\n\n\nClicking a tag will open the Tag Search popup window:\n  \n\n  This will list all Smithy-enabled objects with matching tags, as well as the specific nodes that are set to the same tag.\n\n\n\n\nNode Editor Panel\n\n\n\n\nThe node editor panel is used for adding, editing, and deleting Plug and Socket nodes. It consists of the Generation Depth Panel, Node Palette, and Layer Panel.\n\n\nGeneration Depth\n\n\n\n\nThe generation depth panel sets an \nint\n value the maximum number depth of children this adapter can generate, if it is the base object.\n\n\nIn other words, a base object with a maximum generation depth of \nn\n can have a GameObject hierarchy that is, at most, \nn\n levels deep.\n\n\nFor example:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndepth = 2\n\n\ndepth = 3\n\n\ndepth = 5\n\n\n\n\n\n\n(13 GameObjects at Width = 3)\n\n\n(40 GameObjects at Width = 3)\n\n\n(364 GameObjects at Width = 3)\n\n\n\n\n\n\n\n\n\n  \n\n  Please keep in mind that while generation depth cannot be set to infinity, it can be set very high, and Nodes can be structured to produce hierarchies that expand exponentially. Generation calls that produce very deep hierarchies - especially multiple calls per frame - will \nseverely\n impact performance.\n  \n\n  \n\n\nThe default maximum generation depth is \n5\n\n\nNode Palette\n\n\nThe Node Palette contains the controls to add, move, adjust, and delete nodes.\n\n\nAdd Node Tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd Plug\n\n\nAdd Socket\n\n\nClone Node\n\n\n\n\n\n\n\n\nFrom left to right, the tabs under the add node tab switch the add mode to Plug, Socket, and Clone. Moving the mouse over the object mesh in the \nScene View Window\n will draw a magenta dot - this is the placement point for new nodes. Left click the mouse, and a new node of the selected node type will be at the placement point.\n\n\n\n\n\nClone mode clones the node that is currently selected in the Layer Panel and adds it at the placement point, or as an unanchored node.\n\n\n\n\nSmithy manages an automatically-generated MeshCollider specifically for adding and moving nodes around object models, so you can add nodes directly to the surface of your mesh. To help with placement, the Node Palette includes several mesh snapping options:\n\n\n\n\n\n\n\n\nVertex\n\n\nTriangle Center\n\n\nMidpoint\n\n\nOff\n\n\n\n\n\n\n\n\n\n\nSnaps the placement point to the vertex nearest the mouse cursor\n\n\nSnaps the placement point to the centroid of the face trivector under the mouse cursor\n\n\nSnaps the placement point to the midpoint of the edge nearest the mouse cursor\n\n\nDisables snapping. The placement point will appear at the intersection of a ray fired from the mouse position.\n\n\n\n\n\n\n\n\nHowever, having a mesh isn't necessary, and Smithy will operate on meshless GameObjects. This is useful for creating nodes that handle pure code functions like AI behavior, mesh-agnostic particle effects, audio modifiers, and anything else that is useful for procedural generation but does not necessitate a mesh.\n\n\nEither way, clicking the \n button will add a new node to (0,0,0).\n\n\nEdit Node Tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSelect Node\n\n\nMove Node\n\n\nRotate Node\n\n\nScale Node\n\n\nAdjust Connection Vector\n\n\n\n\n\n\n\n\nFrom left to right, the tabs under the Edit Node Tab set selection mode, move mode, and connection vector mode.\n\n\n\n\nIn \nselection mode\n, left-clicking on a node in the Scene View Window will select that node in the inspector. The Gizmo icon will turn yellow to highlight when it's under the mouse pointer, and green when it has been selected. Nodes can also be selected by clicking the name of the node in the \nLayer Panel\n.\n\n\n\n\nMove mode\n allows repositioning of the selected node. If a node is not currently selected (highlighted green in the Scene View and layer panel), this option will be disabled.\n\n\nMove mode appends a subpanel to the palette with the following icons:\n\n\n\n\nBy default, move mode draws a Unity movement handle in the Scene View that can be used to drag the node around the edit area.\n\n\nBy clicking the \n toggle, the movement handles will disappear and the magenta placement point will appear when the mouse enters the Scene View. Left clicking in the scene view will set the node's position to the placement point position.\n\n\n\n\nBy default, a node moved in this manner will recalculate its' \nConnection Vector\n (it will try to align to the new surface normal). To prevent this behavior, click the \n button, which will toggle connection vector preservation.\n\n\n\n\nAdjust Connection Vector mode\n draws a Unity rotation handle at the node position. This can be dragged in any axis to set the \nConnection Vector\n of the node. This mode will also append the following connection vector quick-set subpanel to the palette:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF\n\n\nN\n\n\nB\n\n\nC\n\n\n\n\n\n\nWorld Up\n\n\nWorld Down\n\n\nWorld Left\n\n\nWorld Right\n\n\nWorld Forward\n\n\nWorld Backward\n\n\nNearest Surface Normal\n\n\nAlign to Object Center\n\n\n\n\n\n\n\n\nClicking any of these options will directly set the node's connection vector.\n\n\nDelete Node Tab\n\n\nDelete mode will delete the node nearest the mouse cursor when left-clicking in the scene view.\n\n\nPalette Information Panel\n\n\n\n\nFor clarity's sake, there is an information box located at the bottom of the palette. This box reports the currently selected option, or set of options.\n\n\nNode Layers\n\n\nNodes on an adapter are collected into layers. These layers are just an organizational tool - they don't affect generation - but can be used to edit multiple nodes at once.\n\n\nAll adapters have at least one layer. Smithy does not allow adapters without layers, and deleting the last layer on an adapter will replace it with a new layer. Layers without nodes are, however, valid.\n\n\nThe current active layer (the layer that will contain nodes added through the \nNode Palette\n) is colored \nteal\n. Inactive layers are colored \nnavy\n, and can be activated by clicking the layer name. Only one layer can be active at a time.\n\n\n Nodes on inactive layers will still contribute to procedural generation, layers are just an organizational tool. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpands or collapses the layer's node list\n\n\n\n\n\n\nLayer 0\n\n\nThe active layer's name.\n\n\n\n\n\n\nLayer 0\n\n\nAn inactive layer name. Click to set as the active layer.\n\n\n\n\n\n\n\n\nOpens the \nLayer Window\n\n\n\n\n\n\n\n\nReverses the ordering of the layer's node list.\n\n\n\n\n\n\n\n\nSort nodes. Nodes can be sorted by \ntype\n, \nname\n, \ntags\n, \nselection probability\n, \nposition\n (x, y, or z), or by visibility.\n\n\n\n\n\n\n\n\nToggle visibility for all nodes in the layer. Invisible nodes will still contribute to generation.\n\n\n\n\n\n\n\n\nDelete the layer and all nodes it contains.\n\n\n\n\n\n\n\n\nNew layers can be added by clicking the \n+\n button below the layers panel.\n\n\nThe nodes in each layer contain their own control pills, which are explained in the \nNode Editor Pills\n section of the documentation on nodes.\n\n\nLayer Window\n\n\n\n\nThe layer window allows several of the \nNode Window\n controls to be applied to multiple nodes at once.\n\n\nThe left column is the node selection set. This is a list of all nodes on the layer, by type and name. The bottom of this column contains buttons for selecting/deselecting all plugs, selecting/deselecting all sockets, and selecting/deselecting all nodes.\n\n\n\n\nThe right-hand column contains the following five controls:\n\n\n The functions of these controls are identical to the controls in the \nNode Settings Window\n. More information about each control is available on that page. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nContains the same set of connection vector quick-set buttons as in the Adjust Connection Vector Mode of the \nNode Palette\n. These buttons function identically to the palette set, and when clicked, the connection vectors of all selected nodes  will be changed.\n\n\n\n\n\n\n\n\nClicking a \nPreset\n will apply values to that preset to all selected nodes.\n\n\n\n\n\n\n\n\nThis is the same \nTag Manager\n as in the \nNode Settings Window\n, but changes here will be applied to all nodes in selection. Tags that appear in multiple nodes will be marked with a number corresponding to the number of nodes selected that contain the tag.\n\n\n\n\n\n\n\n\nLike the \nNode Settings Window\n, but applies the entered \njitter values\n to each node in the selection.\n\n\n\n\n\n\n\n\nMaterial Options\n added here will be copied to all nodes in the selection\n\n\n\n\n\n\n\n\nThese controls operate over every node currently selected in the left hand panel. After a successful operation, a notification box will appear in the window for a few seconds.\n\n\nNode Pills\n\n\nWhen a \nNode Layer\n is expanded, it will show a list of all nodes that exist on that layer. Each node is represented by a pill menu that offers the following controls:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChange the \nNode Type\n of the node.\n\n\n\n\n\n\nNode Name\n\n\nClick to select the Node\n\n\n\n\n\n\n\n\nOpen the \nNode Settings Window\n\n\n\n\n\n\n\n\nReports the number of tags on the node. Clicking will open the node's \ntag manager\n\n\n\n\n\n\n\n\nReports the \nsocket fill probability\n or \nplug selection weight\n of the node. Click to open the node's \nprobability settings window\n\n\n\n\n\n\n\n\nChange the node's \nLayer\n\n\n\n\n\n\n\n\nChange the order of the node in its layer (overrides sorting options)\n\n\n\n\n\n\n\n\nToggle the visibility of the node\n\n\n\n\n\n\n\n\nDelete the node\n\n\n\n\n\n\n\n\n\n\nObject Assembler Panel\n\n\n\n\nThe Object Assembler panel is a quick way to manually build object hierarchies and test generation in the Editor.\n\n\nSocket View Panel\n\n\nThe socket view panel is similar to the \nNode Layer Panel\n, but only displays the sockets on the adapter. Slightly different from the \nNode Editor Node Pills\n, each socket pill contains the following options:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChange the \nNode Type\n of the node. Sockets changed to plugs will be removed from the Object Assembler Socket View\n\n\n\n\n\n\nNode Name\n\n\nClick to select the Node\n\n\n\n\n\n\n\n\nOpen the \nNode Settings Window\n\n\n\n\n\n\n\n\nGenerate a plug object for this node (ignores \nsocket fill probability\n)\n\n\n\n\n\n\n\n\nDestroy the child plug of this socket, if it exists.\n\n\n\n\n\n\n\n\nDisplays the name of the current child plug for this node, if it exists. Clicking on this icon will open the \nPlug Selector Window\n\n\n\n\n\n\n\n\nChange the socket's \nNode Layer\n\n\n\n\n\n\n\n\nChange the order of the socket in its layer\n\n\n\n\n\n\n\n\nToggle the visibility of the socket\n\n\n\n\n\n\n\n\nDelete the socket\n\n\n\n\n\n\n\n\nPlug Selector\n\n\n\n\nClicking the \n button of a socket pill will open the Plug Selector Window, which will show all adapter-enabled prefabs that are valid as plug objects for this socket.\n\n\nClicking one of these objects will instantiate a copy as a plug object for the current socket.\n\n\n\n  If the selected plug object contains multiple plug nodes that are valid for the current socket, a sub-window will ask you to select which node will act as the connection point.\n\n\n\n\n\n\nBy default, the plug selector window will only display plug objects that share one or more \ntags\n with the current socket. Clicking one of these tags will bring up the \ntag search popup\n.\n\n\nClicking the \n button to toggle the tag override mode. While tag override is on, \nany\n plug can be set to the current socket, regardless of tags.\n\n\nGenerating in Editor Mode\n\n\nThe Object Assembler will also let you procedurally generate objects in the editor. At the bottom of the socket view panel, there are four buttons. From left to right:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSet Generator Seed\n\n\nToggle to activate the \ngeneration seed\n\n\n\n\n\n\n\n\nRun Generator\n\n\nProcedurally generate an object hierarchy, using a \ngenerator\n (respects \nsocket fill probability settings\n)\n\n\n\n\n\n\n\n\nFill All Sockets\n\n\nGenerates a plug for every available socket (ignores \nsocket fill probability settings\n)\n\n\n\n\n\n\n\n\nClear All Sockets\n\n\nClear all sockets, destroy all plug objects, and reset the object hierarchy.\n\n\n\n\n\n\n\n\nGeneration Seed\n\n\nAll Smithy \ngenerators\n can take a an \nint\n value as a \nrandom seed\n. Generations with a random seed with always produce the same output given the same inputs. Because Editor and runtime generators operate identically, seeds found in the object assembler and passed to runtime generators will generate the same output.\n\n\nHowever, new inputs like more or fewer available plugs will \"break\" known seeds. That is, the same seed operating over two distinct selection sets will not produce identical results. If seed values are an important part of your project, it's best to only set seeds once all assets and adapters are locked in.\n\n\nSave As Fixed Object\n\n\nThe object assembler can also save out object hierarchies stripped of all Smithy interfaces (\"fixed\"). Clicking the \n at the bottom of the object assembler panel will save a modified copy of the object heirarchy as a prefab.\n\n\nThe prefab will not include any Smithy adapters or nodes, but it will still have the same GameObject parent/child relationships.\n\n\nThis is useful if your project can make use of Smithy's rapid assembly functions, but has no real need for runtime procedural generation.", 
            "title": "Adapters"
        }, 
        {
            "location": "/editor/adapter/#overview", 
            "text": "Smithy Adapters are  Components  that contain  Nodes , and are required for  procedurally generating objects .  Adapters are added by clicking  Add Component  in the GameObject inspector, and selecting  Smithy     Add Smithy Adapter  \n   \n  Please note that Smithy can only load and instantiate Prefabs that are located in the  /Assets/Resources  folder of your Project, or  Asset Bundles  that have already been loaded.", 
            "title": "Overview"
        }, 
        {
            "location": "/editor/adapter/#inspector", 
            "text": "Adapters are equipped with a custom inspector, which is the principal point of access for working with  Nodes . Once a Smithy Adapter component is added to a GameObject, it will appear in that GameObject's component inspector.  Very narrow inspector layouts may make some UI components overlap. If this is the case, widen the inspector window to a comfortable width.", 
            "title": "Inspector"
        }, 
        {
            "location": "/editor/adapter/#navigation", 
            "text": "The Navigation panel accesses the Information Panel, the Node Editor, and the Object Assembler.\n  The Node Editor and Object Assembler are only available when the GameObject is active in the hierarchy. If the GameObject is saved as a prefab, these options will be disabled.", 
            "title": "Navigation"
        }, 
        {
            "location": "/editor/adapter/#saving", 
            "text": "Smithy uses asset labels and prefab assets during procedural generation. Therefore, GameObjects must be saved as prefabs before they can be used by Smithy.  Correctly saved and labeled prefabs are crucial to Smithy's operation, so each Adapter is able to manage the saving of it's linked prefab. Simply activate the autosave in the save menu once a prefab has been linked.  \n   \n  For best results, let Smithy manage the saving and updating of prefabs with that have Smithy Adapters. Smithy will ensure that these prefabs are labeled correctly prior to building, and useable in generation. Manually saving and updating Smithy prefabs is not recommended - it may work, but can't be guaranteed. \n   \n     The top right corner of the navigation panel contains the Save indicator. The icon changes based on state:     Indicator  Status  Description       Unsaved (no prefab)  This GameObject has not been saved as a prefab. Clicking this icon will allow you to save the GameObject and create a prefab connection.     Unsaved  This GameObject has a prefab connection but has unsaved changes. Clicking this icon will save changes to the prefab, or, allow you to activate Smithy's autosave feature.     Saving  This GameObject is currently saving any changes. This should only take a brief moment, but allow it to save before starting a build or entering Game mode.     Prefab OK   (autosave off)  This GameObject has a prefab connection that is current with any changes made. Autosave is not on and the GameObject will need to be saved manually. Click to  activate  autosave.     Prefab OK   (autosave on)  This GameObject has a prefab connection that is current with any changes made. Autosave is on. Click to  deactivate  autosave.", 
            "title": "Saving"
        }, 
        {
            "location": "/editor/adapter/#information-panel", 
            "text": "The information panel is the first navigation panel option and provides an at-a-glance display of all critical Node information. The information panel is comprised of a warning panel, a generation depth counter, and a tag list panel.", 
            "title": "Information Panel"
        }, 
        {
            "location": "/editor/adapter/#warning-panel", 
            "text": "The warning panel will display any issues that might affect the operation of this adapter or its nodes. It has two states:             Valid    Problems Detected (where # is the number of issues)     Issues that Smithy detects are arranged into three categories:     Warning  Important  Critical           These will not cause problems with generation, but may potentially produce undesirable results  These issues are will generate poor or unexpected results, but will not cause errors  This issues are serious and will throw errors or prevent any Nodes on this adapter from being detected.     Alt-clicking the warning icon will open the relevant  troubleshooting  link in a new browser window.", 
            "title": "Warning Panel"
        }, 
        {
            "location": "/editor/adapter/#generation-depth-panel", 
            "text": "Displays the  maximum generation depth  for this adapter.", 
            "title": "Generation Depth Panel"
        }, 
        {
            "location": "/editor/adapter/#tag-list-panel", 
            "text": "Displays a list of all Tags present on the Adapter's nodes. Tags present on Plugs will be shown in  blue , and Tags present on Sockets will be shown in  teal .  Clicking a tag will open the Tag Search popup window:\n   \n  This will list all Smithy-enabled objects with matching tags, as well as the specific nodes that are set to the same tag.", 
            "title": "Tag List Panel"
        }, 
        {
            "location": "/editor/adapter/#node-editor-panel", 
            "text": "The node editor panel is used for adding, editing, and deleting Plug and Socket nodes. It consists of the Generation Depth Panel, Node Palette, and Layer Panel.", 
            "title": "Node Editor Panel"
        }, 
        {
            "location": "/editor/adapter/#generation-depth", 
            "text": "The generation depth panel sets an  int  value the maximum number depth of children this adapter can generate, if it is the base object.  In other words, a base object with a maximum generation depth of  n  can have a GameObject hierarchy that is, at most,  n  levels deep.  For example:            depth = 2  depth = 3  depth = 5    (13 GameObjects at Width = 3)  (40 GameObjects at Width = 3)  (364 GameObjects at Width = 3)     \n   \n  Please keep in mind that while generation depth cannot be set to infinity, it can be set very high, and Nodes can be structured to produce hierarchies that expand exponentially. Generation calls that produce very deep hierarchies - especially multiple calls per frame - will  severely  impact performance.\n   \n    The default maximum generation depth is  5", 
            "title": "Generation Depth"
        }, 
        {
            "location": "/editor/adapter/#node-palette", 
            "text": "The Node Palette contains the controls to add, move, adjust, and delete nodes.", 
            "title": "Node Palette"
        }, 
        {
            "location": "/editor/adapter/#add-node-tab", 
            "text": "Add Plug  Add Socket  Clone Node     From left to right, the tabs under the add node tab switch the add mode to Plug, Socket, and Clone. Moving the mouse over the object mesh in the  Scene View Window  will draw a magenta dot - this is the placement point for new nodes. Left click the mouse, and a new node of the selected node type will be at the placement point.   \nClone mode clones the node that is currently selected in the Layer Panel and adds it at the placement point, or as an unanchored node.  Smithy manages an automatically-generated MeshCollider specifically for adding and moving nodes around object models, so you can add nodes directly to the surface of your mesh. To help with placement, the Node Palette includes several mesh snapping options:     Vertex  Triangle Center  Midpoint  Off      Snaps the placement point to the vertex nearest the mouse cursor  Snaps the placement point to the centroid of the face trivector under the mouse cursor  Snaps the placement point to the midpoint of the edge nearest the mouse cursor  Disables snapping. The placement point will appear at the intersection of a ray fired from the mouse position.     However, having a mesh isn't necessary, and Smithy will operate on meshless GameObjects. This is useful for creating nodes that handle pure code functions like AI behavior, mesh-agnostic particle effects, audio modifiers, and anything else that is useful for procedural generation but does not necessitate a mesh.  Either way, clicking the   button will add a new node to (0,0,0).", 
            "title": "Add Node Tab"
        }, 
        {
            "location": "/editor/adapter/#edit-node-tab", 
            "text": "Select Node  Move Node  Rotate Node  Scale Node  Adjust Connection Vector     From left to right, the tabs under the Edit Node Tab set selection mode, move mode, and connection vector mode.   In  selection mode , left-clicking on a node in the Scene View Window will select that node in the inspector. The Gizmo icon will turn yellow to highlight when it's under the mouse pointer, and green when it has been selected. Nodes can also be selected by clicking the name of the node in the  Layer Panel .   Move mode  allows repositioning of the selected node. If a node is not currently selected (highlighted green in the Scene View and layer panel), this option will be disabled.  Move mode appends a subpanel to the palette with the following icons:   By default, move mode draws a Unity movement handle in the Scene View that can be used to drag the node around the edit area.  By clicking the   toggle, the movement handles will disappear and the magenta placement point will appear when the mouse enters the Scene View. Left clicking in the scene view will set the node's position to the placement point position.   By default, a node moved in this manner will recalculate its'  Connection Vector  (it will try to align to the new surface normal). To prevent this behavior, click the   button, which will toggle connection vector preservation.   Adjust Connection Vector mode  draws a Unity rotation handle at the node position. This can be dragged in any axis to set the  Connection Vector  of the node. This mode will also append the following connection vector quick-set subpanel to the palette:", 
            "title": "Edit Node Tab"
        }, 
        {
            "location": "/editor/adapter/#delete-node-tab", 
            "text": "Delete mode will delete the node nearest the mouse cursor when left-clicking in the scene view.", 
            "title": "Delete Node Tab"
        }, 
        {
            "location": "/editor/adapter/#palette-information-panel", 
            "text": "For clarity's sake, there is an information box located at the bottom of the palette. This box reports the currently selected option, or set of options.", 
            "title": "Palette Information Panel"
        }, 
        {
            "location": "/editor/adapter/#node-layers", 
            "text": "Nodes on an adapter are collected into layers. These layers are just an organizational tool - they don't affect generation - but can be used to edit multiple nodes at once.  All adapters have at least one layer. Smithy does not allow adapters without layers, and deleting the last layer on an adapter will replace it with a new layer. Layers without nodes are, however, valid.  The current active layer (the layer that will contain nodes added through the  Node Palette ) is colored  teal . Inactive layers are colored  navy , and can be activated by clicking the layer name. Only one layer can be active at a time.   Nodes on inactive layers will still contribute to procedural generation, layers are just an organizational tool.              Expands or collapses the layer's node list    Layer 0  The active layer's name.    Layer 0  An inactive layer name. Click to set as the active layer.     Opens the  Layer Window     Reverses the ordering of the layer's node list.     Sort nodes. Nodes can be sorted by  type ,  name ,  tags ,  selection probability ,  position  (x, y, or z), or by visibility.     Toggle visibility for all nodes in the layer. Invisible nodes will still contribute to generation.     Delete the layer and all nodes it contains.     New layers can be added by clicking the  +  button below the layers panel.  The nodes in each layer contain their own control pills, which are explained in the  Node Editor Pills  section of the documentation on nodes.", 
            "title": "Node Layers"
        }, 
        {
            "location": "/editor/adapter/#layer-window", 
            "text": "The layer window allows several of the  Node Window  controls to be applied to multiple nodes at once.  The left column is the node selection set. This is a list of all nodes on the layer, by type and name. The bottom of this column contains buttons for selecting/deselecting all plugs, selecting/deselecting all sockets, and selecting/deselecting all nodes.   The right-hand column contains the following five controls:   The functions of these controls are identical to the controls in the  Node Settings Window . More information about each control is available on that page.             Contains the same set of connection vector quick-set buttons as in the Adjust Connection Vector Mode of the  Node Palette . These buttons function identically to the palette set, and when clicked, the connection vectors of all selected nodes  will be changed.     Clicking a  Preset  will apply values to that preset to all selected nodes.     This is the same  Tag Manager  as in the  Node Settings Window , but changes here will be applied to all nodes in selection. Tags that appear in multiple nodes will be marked with a number corresponding to the number of nodes selected that contain the tag.     Like the  Node Settings Window , but applies the entered  jitter values  to each node in the selection.     Material Options  added here will be copied to all nodes in the selection     These controls operate over every node currently selected in the left hand panel. After a successful operation, a notification box will appear in the window for a few seconds.", 
            "title": "Layer Window"
        }, 
        {
            "location": "/editor/adapter/#node-pills", 
            "text": "When a  Node Layer  is expanded, it will show a list of all nodes that exist on that layer. Each node is represented by a pill menu that offers the following controls:            Change the  Node Type  of the node.    Node Name  Click to select the Node     Open the  Node Settings Window     Reports the number of tags on the node. Clicking will open the node's  tag manager     Reports the  socket fill probability  or  plug selection weight  of the node. Click to open the node's  probability settings window     Change the node's  Layer     Change the order of the node in its layer (overrides sorting options)     Toggle the visibility of the node     Delete the node", 
            "title": "Node Pills"
        }, 
        {
            "location": "/editor/adapter/#object-assembler-panel", 
            "text": "The Object Assembler panel is a quick way to manually build object hierarchies and test generation in the Editor.", 
            "title": "Object Assembler Panel"
        }, 
        {
            "location": "/editor/adapter/#socket-view-panel", 
            "text": "The socket view panel is similar to the  Node Layer Panel , but only displays the sockets on the adapter. Slightly different from the  Node Editor Node Pills , each socket pill contains the following options:            Change the  Node Type  of the node. Sockets changed to plugs will be removed from the Object Assembler Socket View    Node Name  Click to select the Node     Open the  Node Settings Window     Generate a plug object for this node (ignores  socket fill probability )     Destroy the child plug of this socket, if it exists.     Displays the name of the current child plug for this node, if it exists. Clicking on this icon will open the  Plug Selector Window     Change the socket's  Node Layer     Change the order of the socket in its layer     Toggle the visibility of the socket     Delete the socket", 
            "title": "Socket View Panel"
        }, 
        {
            "location": "/editor/adapter/#plug-selector", 
            "text": "Clicking the   button of a socket pill will open the Plug Selector Window, which will show all adapter-enabled prefabs that are valid as plug objects for this socket.  Clicking one of these objects will instantiate a copy as a plug object for the current socket.  \n  If the selected plug object contains multiple plug nodes that are valid for the current socket, a sub-window will ask you to select which node will act as the connection point.   By default, the plug selector window will only display plug objects that share one or more  tags  with the current socket. Clicking one of these tags will bring up the  tag search popup .  Clicking the   button to toggle the tag override mode. While tag override is on,  any  plug can be set to the current socket, regardless of tags.", 
            "title": "Plug Selector"
        }, 
        {
            "location": "/editor/adapter/#generating-in-editor-mode", 
            "text": "The Object Assembler will also let you procedurally generate objects in the editor. At the bottom of the socket view panel, there are four buttons. From left to right:             Set Generator Seed  Toggle to activate the  generation seed     Run Generator  Procedurally generate an object hierarchy, using a  generator  (respects  socket fill probability settings )     Fill All Sockets  Generates a plug for every available socket (ignores  socket fill probability settings )     Clear All Sockets  Clear all sockets, destroy all plug objects, and reset the object hierarchy.", 
            "title": "Generating in Editor Mode"
        }, 
        {
            "location": "/editor/adapter/#generation-seed", 
            "text": "All Smithy  generators  can take a an  int  value as a  random seed . Generations with a random seed with always produce the same output given the same inputs. Because Editor and runtime generators operate identically, seeds found in the object assembler and passed to runtime generators will generate the same output.  However, new inputs like more or fewer available plugs will \"break\" known seeds. That is, the same seed operating over two distinct selection sets will not produce identical results. If seed values are an important part of your project, it's best to only set seeds once all assets and adapters are locked in.", 
            "title": "Generation Seed"
        }, 
        {
            "location": "/editor/adapter/#save-as-fixed-object", 
            "text": "The object assembler can also save out object hierarchies stripped of all Smithy interfaces (\"fixed\"). Clicking the   at the bottom of the object assembler panel will save a modified copy of the object heirarchy as a prefab.  The prefab will not include any Smithy adapters or nodes, but it will still have the same GameObject parent/child relationships.  This is useful if your project can make use of Smithy's rapid assembly functions, but has no real need for runtime procedural generation.", 
            "title": "Save As Fixed Object"
        }, 
        {
            "location": "/editor/node/", 
            "text": "Overview\n\n\nNodes are the \"connection points\" that Smithy uses to assemble GameObjects into new hierarchies. Multiple nodes can exist on a single adapter, and a Smithy-adapted GameObject might be host to one or hundreds of individual nodes, each with \nparameters\n that control when and how they are used in \nprocedural generation\n\n\nType\n\n\nThere are two types of nodes: Plugs and Sockets.\n\n\nPlugs \nattach to\n Sockets, and Sockets \naccept\n plugs.\n\n\nPlugs\n\n\n\n\n\n  Plugs \nplug in\n to sockets. That's pretty much all you have to remember.\n\n\n\n\nSmithy actually largely ignores GameObjects during \ngeneration\n, and instead only searches plugs. This means that your Smithy-adapted prefabs won't be selected, but its plugs will, and the prefab will be instantiated to get the plug. Keep this in mind when creating assets and assigning weights. Multiple plugs on a single GameObject means multiple points of connection, but in terms of \nthat specific GameObject being selected\n the weights are cumulative.\n\n\nIn other words, a \nGameObject\n that has ten identical plugs of weight 2 has an effective total selection weight of 20.\n\n\nRealistically, this will be in issue only in some projects, and even then very rarely. Just keep this in mind if you want a GameObject with many plugs to generate only very rarely.\n\n\nSockets\n\n\n\n\n\n  Sockets \naccept\n plugs, just like the ones you've got on your wall.\n\n\n\n\nYou can have as many sockets as you want on a GameObject, but each socket can only hold one plug. However, plug objects themselves can hold other sockets (which can hold plugs). For more information, \nconsult the generation page\n.\n\n\nTags\n\n\nTags control which sockets and plugs are able to link together. Smithy uses the same tag system that already \nexists within Unity\n. However, Smithy ignores tags on GameObjects and only considers tags on nodes themselves.\n\n\nTo add and remove tags from a node, click the \n on the Node Editor \nNode Pill\n to open the \nTag Manager Window\n, or assign tags in the \nNode Settings Window\n.\n\n\nDuring \ngeneration\n Smithy will take a socket node and look for any plug nodes that have one or more matching tags. Therefore:\n\n\n\n\nFor plugs to be used, they must share one or more tags with a socket.\n\n\nFor sockets to be filled, they must share one or more tags with at least one plug.\n\n\n\n\n\n\nSmithy will \nautomatically notify you\n about nodes that are missing tags. Also, the \nSmithy Manager's Diagnose function\n will alert you to any tags that exist only on sockets or only on tags (and are therefore prevented from generating).\n\n\nThe Manager's \naggressive repair function\n can find an eliminate nodes with orphaned tags, as well.\n\n\nGeneration Probability\n\n\nSelection is extremely important to procedural generation, and Smithy includes tools to carefully manage how frequently plugs are selected and how often sockets are filled.\n\n\nSocket Fill Probability\n\n\nSocket fill probability is fairly straightforward - it is a percentage that determines how often the socket will generate a plug. Sockets with low values will rarely generate a plug, whereas sockets with a 100% socket fill probability will \nalways\n generate a plug.\n\n\nWhen using \nProbability Presets\n, sockets use the \nPercentage\n preset value.\n\n\nPlug Weight\n\n\nDuring plug \ngeneration\n for a socket node, Smithy collects all plugs that have \ntags\n that match the socket's tags. From this collection, Smithy makes a selection based on weight.\n\n\nWeight values refer to how likely it is that a plug will be chosen, with higher weights being picked more frequently. A weight of 2 will be selected twice as often as a weight of 1, and a weight of 4 twice as often as a weight of 2.  \n\n\nWeights can be thought of as instances of a selection in an array of all cumulative selections. This is shown more clearly in a sample set with a cumulative weight of 22:\n\n\n\n\n\n\n\n\nItem\n\n\nWeight\n\n\nSelection Frequency\n\n\n\n\n\n\n\n\n\n\nA\n\n\n1\n\n\n4.6%\n\n\n\n\n\n\nB\n\n\n2\n\n\n9.1%\n\n\n\n\n\n\nC\n\n\n4\n\n\n18.41%\n\n\n\n\n\n\nD\n\n\n5\n\n\n22.3%\n\n\n\n\n\n\nE\n\n\n10\n\n\n45.75%\n\n\n\n\n\n\n\n\nIf this is confusing, \ndon't panic\n! The \nProbability Preset Manager\n has visual tools that will help you determine socket fill probabilities and plug weights that are perfect for your project, and \nas you'll see below\n, you'll never have to individually set these numbers (although you can if you want)\n\n\n\n\nNode Settings Window\n\n\nThe Node Settings Window is activated by the \n button on the \nNode Editor Node Pill\n and \nObject Assembler Socket Pill\n. It contains controls for fine-tuning nodes, as well as adding special generation options for specific nodes.\n\n\nNode \ntype\n can be set by clicking the node type icon in the top-left corner of the window.\n\n\nName\n\n\nClick the \n button to set the name of the Node. Nodes, by default, are named based on their \nVector3\n position offset from the Adapter's transform origin.\n\n\n  It is \nstrongly recommended\n to name nodes when working with complex node structures.\n\n\n\nPosition\n\n\nNodes are configured in relation to the origin of the Transform of the GameObject their connected to. This means that properties of a node like position, connection vector, rotation, and scale are properties \nrelative to\n the Transform. If the Transform is translated, rotated or scaled, the nodes will be modified likewise.\n\n\nFor this reason, the Position value can be more correctly thought of as a position \noffset\n from the Transform origin.\n\n\nChanging the values here will move the node position in world space relative to the Transform origin.\n\n\nRotation\n\n\nTo-do.\n\n\nScale\n\n\nTo-do.\n\n\nConnection Vector\n\n\nThe connection vector is the vector of attachment between plugs and sockets. \nGenerated\n plug objects will be oriented so that their connection vectors (in world space) are inverse vectors.\n\n\nIn short: generated plugs will be oriented so that their connection vector and the socket connection vectors are pointing towards each other, like so:\n\n\n\n\nTo avoid gimbal lock, the connection vector is a \nVector4\n. It can be set directly in this window, or it can be set in the Node Editor's \nAdjust Connection Angle Tab\n, or by using a snap option.\n\n\nConnection Angle Snap Options\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nF\n\n\nN\n\n\nB\n\n\nC\n\n\n\n\n\n\nWorld Up\n\n\nWorld Down\n\n\nWorld Left\n\n\nWorld Right\n\n\nWorld Forward\n\n\nWorld Backward\n\n\nNearest Surface Normal\n\n\nAlign to Object Center\n\n\n\n\n\n\n\n\nClicking any of these options will directly set the node's connection vector.\n\n\nTag Manager\n\n\n\n\nThe Tag Manager can quickly add and remove \ntags\n from a node.\n\n\nThe left panel contains all the tags available in the project. Clicking one will assign that tag to the current node.\n\n\nThe right panel contains all tags assigned to the current node. Clicking a tag in this panel will remove it from the node.\n\n\nUse the \n filter text box to filter tags by name. You can also click the \n toggle to hide and show the default Unity tags (Untagged, Respawn, Finish, EditorOnly, MainCamera, Player, and GameController)\n\n\nClicking the \n+\n button will open a pop-up that will allow you to add a new tag within the Node Settings Window.\n\n\nProbability Settings\n\n\nThis control sets the \nsocket fill probability\n or \nplug selection weight\n.\n\n\nPresets\n\n\nThese presets hold the percentage and weight values set in the \npreset manager\n. Clicking a preset icon will assign its value to the currently selected node.\n\n\nGeneration Jitter\n\n\n\"Jitter\" in Smithy is a maximum allowed deviation value. Generated objects will be affected anywhere from 0% to the maximum of the jitter value. For example, a size jitter of 1% would cause all generated instances of this node's GameObject to scale up by 0-1%.\n\n\n\n\nSmall amounts of jitter are \nextremely\n useful in making procedurally generated assets look hand-crafted.\n\n\n\n  In Smithy, all Jitter is \nadditive\n. Smithy will add jitter values from the socket to the values from its plug, and use the sum as the new maximum deviation when calculating jitter.\n\n\n\n\nJitter can be disabled during \ngenerator instantiation\n.\n\n\nPosition Jitter\n\n\nHow far the generated object can deviate from the node position. Uniform scaling adds the same value to all axes, while individual scaling can generate different values for each axis.\n\n\nRotation Jitter\n\n\nHow far the generated object can deviate from the its default transform rotation. This is applied \nafter\n the \nconnection vectors\n are aligned after instantiation. Uniform scaling adds the same value to all axes, while individual scaling can generate different values for each axis.\n\n\nSize Jitter\n\n\nHow far the generated object can deviate from its default scale. This is applied \nafter\n scaling based on the parent object's scale. Uniform scaling scales the object by a percentage, whereas individual scaling applies a scale modifier per axis.\n\n\nMaterial Options\n\n\nAdditional materials (and weights) can be added to any node. On generation, these materials are selected by weight and applied to the plug object.\n\n\nLike jitter, material options are \nadditive\n. Smithy will collect materials from both the plug and the socket before applying the material to the plug. This is useful if the socket should determine the plug object's material (e.g. keeping materials consistent across an object)\n\n\n\n\nThe material options panel includes a control to set the weight of the default material. Default, in this case, means the material the plug is assigned as a prefab. The defauly weight is \n100\n.\n\n\nMaterials can be added by clicking the \n+\n button. It will open the following window:\n\n\n\n\nFrom here, click a material to assign it to the node. Each material selection will have its own listing in the material options panel.\n\n\nThe input field sets the material option's selection weight, which operates identically to the \nplug selection weight\n. Clicking the \n button will set a \nprobability preset\n weight value for the material, and clicking the \n button will open the \nProbability Preset Manager\n.", 
            "title": "Nodes"
        }, 
        {
            "location": "/editor/node/#overview", 
            "text": "Nodes are the \"connection points\" that Smithy uses to assemble GameObjects into new hierarchies. Multiple nodes can exist on a single adapter, and a Smithy-adapted GameObject might be host to one or hundreds of individual nodes, each with  parameters  that control when and how they are used in  procedural generation", 
            "title": "Overview"
        }, 
        {
            "location": "/editor/node/#type", 
            "text": "There are two types of nodes: Plugs and Sockets.  Plugs  attach to  Sockets, and Sockets  accept  plugs.", 
            "title": "Type"
        }, 
        {
            "location": "/editor/node/#plugs", 
            "text": "Plugs  plug in  to sockets. That's pretty much all you have to remember.  Smithy actually largely ignores GameObjects during  generation , and instead only searches plugs. This means that your Smithy-adapted prefabs won't be selected, but its plugs will, and the prefab will be instantiated to get the plug. Keep this in mind when creating assets and assigning weights. Multiple plugs on a single GameObject means multiple points of connection, but in terms of  that specific GameObject being selected  the weights are cumulative.  In other words, a  GameObject  that has ten identical plugs of weight 2 has an effective total selection weight of 20.  Realistically, this will be in issue only in some projects, and even then very rarely. Just keep this in mind if you want a GameObject with many plugs to generate only very rarely.", 
            "title": "Plugs"
        }, 
        {
            "location": "/editor/node/#sockets", 
            "text": "Sockets  accept  plugs, just like the ones you've got on your wall.  You can have as many sockets as you want on a GameObject, but each socket can only hold one plug. However, plug objects themselves can hold other sockets (which can hold plugs). For more information,  consult the generation page .", 
            "title": "Sockets"
        }, 
        {
            "location": "/editor/node/#tags", 
            "text": "Tags control which sockets and plugs are able to link together. Smithy uses the same tag system that already  exists within Unity . However, Smithy ignores tags on GameObjects and only considers tags on nodes themselves.  To add and remove tags from a node, click the   on the Node Editor  Node Pill  to open the  Tag Manager Window , or assign tags in the  Node Settings Window .  During  generation  Smithy will take a socket node and look for any plug nodes that have one or more matching tags. Therefore:   For plugs to be used, they must share one or more tags with a socket.  For sockets to be filled, they must share one or more tags with at least one plug.    Smithy will  automatically notify you  about nodes that are missing tags. Also, the  Smithy Manager's Diagnose function  will alert you to any tags that exist only on sockets or only on tags (and are therefore prevented from generating).  The Manager's  aggressive repair function  can find an eliminate nodes with orphaned tags, as well.", 
            "title": "Tags"
        }, 
        {
            "location": "/editor/node/#generation-probability", 
            "text": "Selection is extremely important to procedural generation, and Smithy includes tools to carefully manage how frequently plugs are selected and how often sockets are filled.", 
            "title": "Generation Probability"
        }, 
        {
            "location": "/editor/node/#socket-fill-probability", 
            "text": "Socket fill probability is fairly straightforward - it is a percentage that determines how often the socket will generate a plug. Sockets with low values will rarely generate a plug, whereas sockets with a 100% socket fill probability will  always  generate a plug.  When using  Probability Presets , sockets use the  Percentage  preset value.", 
            "title": "Socket Fill Probability"
        }, 
        {
            "location": "/editor/node/#plug-weight", 
            "text": "During plug  generation  for a socket node, Smithy collects all plugs that have  tags  that match the socket's tags. From this collection, Smithy makes a selection based on weight.  Weight values refer to how likely it is that a plug will be chosen, with higher weights being picked more frequently. A weight of 2 will be selected twice as often as a weight of 1, and a weight of 4 twice as often as a weight of 2.    Weights can be thought of as instances of a selection in an array of all cumulative selections. This is shown more clearly in a sample set with a cumulative weight of 22:     Item  Weight  Selection Frequency      A  1  4.6%    B  2  9.1%    C  4  18.41%    D  5  22.3%    E  10  45.75%     If this is confusing,  don't panic ! The  Probability Preset Manager  has visual tools that will help you determine socket fill probabilities and plug weights that are perfect for your project, and  as you'll see below , you'll never have to individually set these numbers (although you can if you want)", 
            "title": "Plug Weight"
        }, 
        {
            "location": "/editor/node/#node-settings-window", 
            "text": "The Node Settings Window is activated by the   button on the  Node Editor Node Pill  and  Object Assembler Socket Pill . It contains controls for fine-tuning nodes, as well as adding special generation options for specific nodes.  Node  type  can be set by clicking the node type icon in the top-left corner of the window.", 
            "title": "Node Settings Window"
        }, 
        {
            "location": "/editor/node/#name", 
            "text": "Click the   button to set the name of the Node. Nodes, by default, are named based on their  Vector3  position offset from the Adapter's transform origin. \n  It is  strongly recommended  to name nodes when working with complex node structures.", 
            "title": "Name"
        }, 
        {
            "location": "/editor/node/#position", 
            "text": "Nodes are configured in relation to the origin of the Transform of the GameObject their connected to. This means that properties of a node like position, connection vector, rotation, and scale are properties  relative to  the Transform. If the Transform is translated, rotated or scaled, the nodes will be modified likewise.  For this reason, the Position value can be more correctly thought of as a position  offset  from the Transform origin.  Changing the values here will move the node position in world space relative to the Transform origin.", 
            "title": "Position"
        }, 
        {
            "location": "/editor/node/#rotation", 
            "text": "To-do.", 
            "title": "Rotation"
        }, 
        {
            "location": "/editor/node/#scale", 
            "text": "To-do.", 
            "title": "Scale"
        }, 
        {
            "location": "/editor/node/#connection-vector", 
            "text": "The connection vector is the vector of attachment between plugs and sockets.  Generated  plug objects will be oriented so that their connection vectors (in world space) are inverse vectors.  In short: generated plugs will be oriented so that their connection vector and the socket connection vectors are pointing towards each other, like so:   To avoid gimbal lock, the connection vector is a  Vector4 . It can be set directly in this window, or it can be set in the Node Editor's  Adjust Connection Angle Tab , or by using a snap option.", 
            "title": "Connection Vector"
        }, 
        {
            "location": "/editor/node/#connection-angle-snap-options", 
            "text": "", 
            "title": "Connection Angle Snap Options"
        }, 
        {
            "location": "/editor/node/#tag-manager", 
            "text": "The Tag Manager can quickly add and remove  tags  from a node.  The left panel contains all the tags available in the project. Clicking one will assign that tag to the current node.  The right panel contains all tags assigned to the current node. Clicking a tag in this panel will remove it from the node.  Use the   filter text box to filter tags by name. You can also click the   toggle to hide and show the default Unity tags (Untagged, Respawn, Finish, EditorOnly, MainCamera, Player, and GameController)  Clicking the  +  button will open a pop-up that will allow you to add a new tag within the Node Settings Window.", 
            "title": "Tag Manager"
        }, 
        {
            "location": "/editor/node/#probability-settings", 
            "text": "This control sets the  socket fill probability  or  plug selection weight .", 
            "title": "Probability Settings"
        }, 
        {
            "location": "/editor/node/#presets", 
            "text": "These presets hold the percentage and weight values set in the  preset manager . Clicking a preset icon will assign its value to the currently selected node.", 
            "title": "Presets"
        }, 
        {
            "location": "/editor/node/#generation-jitter", 
            "text": "\"Jitter\" in Smithy is a maximum allowed deviation value. Generated objects will be affected anywhere from 0% to the maximum of the jitter value. For example, a size jitter of 1% would cause all generated instances of this node's GameObject to scale up by 0-1%.   Small amounts of jitter are  extremely  useful in making procedurally generated assets look hand-crafted.  \n  In Smithy, all Jitter is  additive . Smithy will add jitter values from the socket to the values from its plug, and use the sum as the new maximum deviation when calculating jitter.  Jitter can be disabled during  generator instantiation .", 
            "title": "Generation Jitter"
        }, 
        {
            "location": "/editor/node/#position-jitter", 
            "text": "How far the generated object can deviate from the node position. Uniform scaling adds the same value to all axes, while individual scaling can generate different values for each axis.", 
            "title": "Position Jitter"
        }, 
        {
            "location": "/editor/node/#rotation-jitter", 
            "text": "How far the generated object can deviate from the its default transform rotation. This is applied  after  the  connection vectors  are aligned after instantiation. Uniform scaling adds the same value to all axes, while individual scaling can generate different values for each axis.", 
            "title": "Rotation Jitter"
        }, 
        {
            "location": "/editor/node/#size-jitter", 
            "text": "How far the generated object can deviate from its default scale. This is applied  after  scaling based on the parent object's scale. Uniform scaling scales the object by a percentage, whereas individual scaling applies a scale modifier per axis.", 
            "title": "Size Jitter"
        }, 
        {
            "location": "/editor/node/#material-options", 
            "text": "Additional materials (and weights) can be added to any node. On generation, these materials are selected by weight and applied to the plug object.  Like jitter, material options are  additive . Smithy will collect materials from both the plug and the socket before applying the material to the plug. This is useful if the socket should determine the plug object's material (e.g. keeping materials consistent across an object)   The material options panel includes a control to set the weight of the default material. Default, in this case, means the material the plug is assigned as a prefab. The defauly weight is  100 .  Materials can be added by clicking the  +  button. It will open the following window:   From here, click a material to assign it to the node. Each material selection will have its own listing in the material options panel.  The input field sets the material option's selection weight, which operates identically to the  plug selection weight . Clicking the   button will set a  probability preset  weight value for the material, and clicking the   button will open the  Probability Preset Manager .", 
            "title": "Material Options"
        }, 
        {
            "location": "/editor/manager/", 
            "text": "Overview\n\n\nSmithy requires no global configuration and all of its controls are contained within \nAdapters\n, but Smithy comes with two management windows designed to make using Smithy even easier.\n\n\nThe management tools are located in the Unity Editor menu bar, under \nWindow\n \n \nSmithy\n\n\nSmithy Manager\n\n\n\n  The Smithy Manger contains Smithy's automated repair tools, as well as a report generator that can export information about \nadapters\n and \nnodes\n.\n\n\nAccessed from the Unity Editor menu bar under \nWindow\n \n \nSmithy\n \n \nSmithy Manager\n or by pressing  \nCtrl\n + \nShift\n + \nM\n\n\nContact Links\n\n\nLinks to contact methods, Unity Forum and Asset Store pages, and this documentation can be found on the left side of this window. Clicking any of these links will open a new browser window. The same links can be found \nat this documentation's index page\n.\n\n\nObject Browser\n\n\n\n\nThe Object Browser will find and list all prefabs that contain a \nSmithy adapter\n. Clicking one of the objects in this panel will select the prefab in the \nUnity Project View\n\n\nIf an object in your project is not appearing in the object browser, check to make sure it has an adapter component, and is saved as a prefab. If that still doesn't work, open the \nrepair\n panel.\n\n\nDiagnose and Repair\n\n\n\n\nSmithy will \nwarn you about\n about configurations that could result in suboptimal \ngeneration\n or nodes that fail to generate under any circumstances.\n\n\nThis tool searches all Smithy-enabled prefabs and lists those warnings. On the right side of the report, there are two wrench icons:\n\n\nStandard Repair\n\n\n  Smithy will attempt to repair all assets with outstanding issues.\n\n\nSpecifically:\n- It will remove missing materials from \nmaterial options\n lists,\n- It will remove plug tags that aren't attributed to any socket\n- It will remove socket tags that aren't attributed to any plug\n\n\nAggressive Repair\n\n\n  Smithy will attempt to repair all assets with outstanding issues. It will destroy nodes that cannot spawn.\n\n\nAggressive repair will repair the same issues that standard repair does, but it will also destroy any nodes that have not been assigned tags, or whose tags have been deleted from the project's tag array. It will also destroy nodes that have been rendered tagless because of the removal of orphaned tags.\n\n\n\n  Nodes deleted in this manner are not recoverable with Unity's Undo function.\n\n\n\n\nGenerate Report\n\n\n\n\nThe report window will generate a detailed report of all saved adapters, their nodes, and details about each node. Please remember that Smithy cannot select an adapter \nunless it is saved in a GameObject prefab\n.\n\n\nThe report in this window can be saved as an HTML file by clicking the \n button.\n\n\nProbability Preset Manager\n\n\n\n\nThe Probability Preset Manager is a tool to achieve consistent \ngeneration\n results over any number of \nplugs\n and \nsockets\n. In this window you are able to add, edit, and delete presets that contain selection weight and percentage values.\n\n\nWhen editing \nnodes\n, these values can be assigned instantly by clicking the preset icon.\n\n\n\n\nClicking the \n button in the bottom right corner of the window will save the current preset list for use in the project.\n\n\nThe \n button in the lower left corner will revert the preset list to the default list that comes with the Smithy Asset.\n\n\nClicking the \n in the window bar will exit the manager and discard any unsaved changes.\n\n\n\n\nAccessed from the Unity Editor menu bar under \nWindow\n \n \nSmithy\n \n \nPreset Manager\n or by pressing  \nCtrl\n + \nShift\n + \nR\n\n\nPresets\n\n\nPresets hold a selection weight and a fill probability. When saved, they will appear in \nnode generation probability panels\n. Clicking their icon will set plug nodes to the preset weight value, and selection nodes to the preset fill probability.\n\n\nPresets are usually displayed in Smithy by their icon, and icons can be set by clicking the \n button that is superimposed on the preset icon. Doing so will open the following window:\n\n\n\n\n\n\nThe first row of sliders set the red, green, and blue values for the icon's foreground color.\n\n\nThe second row sets the red, green, and blue values for the icon's background color.\n\n\nThe lower panel of this window sets a \nFont Awesome glyph\n as the preset's icon.\n\n\n\n\nTo add a new preset to your project, click the \n button.\n\n\nVisualizer\n\n\n\n\nThe visualizer updates automatically as you add, remove, or edit presets.\n\n\nThe right half of the preset manager window is a selection weight visualizer. Smithy simulates 10,000 selections (by default) and reports how often each preset was selected. By hovering over a column of the bar chart Smithy will report how often that preset has been selected, and the relative probability of that preset being selected.\n\n\nThe integer input in the upper right-hand corner represents the number of selections the simulation makes while updating. Higher values result in more accurate results, but are more performance-intensive and may result in lag when using this manager.", 
            "title": "Managers"
        }, 
        {
            "location": "/editor/manager/#overview", 
            "text": "Smithy requires no global configuration and all of its controls are contained within  Adapters , but Smithy comes with two management windows designed to make using Smithy even easier.  The management tools are located in the Unity Editor menu bar, under  Window     Smithy", 
            "title": "Overview"
        }, 
        {
            "location": "/editor/manager/#smithy-manager", 
            "text": "The Smithy Manger contains Smithy's automated repair tools, as well as a report generator that can export information about  adapters  and  nodes .  Accessed from the Unity Editor menu bar under  Window     Smithy     Smithy Manager  or by pressing   Ctrl  +  Shift  +  M", 
            "title": "Smithy Manager"
        }, 
        {
            "location": "/editor/manager/#contact-links", 
            "text": "Links to contact methods, Unity Forum and Asset Store pages, and this documentation can be found on the left side of this window. Clicking any of these links will open a new browser window. The same links can be found  at this documentation's index page .", 
            "title": "Contact Links"
        }, 
        {
            "location": "/editor/manager/#object-browser", 
            "text": "The Object Browser will find and list all prefabs that contain a  Smithy adapter . Clicking one of the objects in this panel will select the prefab in the  Unity Project View  If an object in your project is not appearing in the object browser, check to make sure it has an adapter component, and is saved as a prefab. If that still doesn't work, open the  repair  panel.", 
            "title": "Object Browser"
        }, 
        {
            "location": "/editor/manager/#diagnose-and-repair", 
            "text": "Smithy will  warn you about  about configurations that could result in suboptimal  generation  or nodes that fail to generate under any circumstances.  This tool searches all Smithy-enabled prefabs and lists those warnings. On the right side of the report, there are two wrench icons:", 
            "title": "Diagnose and Repair"
        }, 
        {
            "location": "/editor/manager/#standard-repair", 
            "text": "Smithy will attempt to repair all assets with outstanding issues.  Specifically:\n- It will remove missing materials from  material options  lists,\n- It will remove plug tags that aren't attributed to any socket\n- It will remove socket tags that aren't attributed to any plug", 
            "title": "Standard Repair"
        }, 
        {
            "location": "/editor/manager/#aggressive-repair", 
            "text": "Smithy will attempt to repair all assets with outstanding issues. It will destroy nodes that cannot spawn.  Aggressive repair will repair the same issues that standard repair does, but it will also destroy any nodes that have not been assigned tags, or whose tags have been deleted from the project's tag array. It will also destroy nodes that have been rendered tagless because of the removal of orphaned tags.  \n  Nodes deleted in this manner are not recoverable with Unity's Undo function.", 
            "title": "Aggressive Repair"
        }, 
        {
            "location": "/editor/manager/#generate-report", 
            "text": "The report window will generate a detailed report of all saved adapters, their nodes, and details about each node. Please remember that Smithy cannot select an adapter  unless it is saved in a GameObject prefab .  The report in this window can be saved as an HTML file by clicking the   button.", 
            "title": "Generate Report"
        }, 
        {
            "location": "/editor/manager/#probability-preset-manager", 
            "text": "The Probability Preset Manager is a tool to achieve consistent  generation  results over any number of  plugs  and  sockets . In this window you are able to add, edit, and delete presets that contain selection weight and percentage values.  When editing  nodes , these values can be assigned instantly by clicking the preset icon.   Clicking the   button in the bottom right corner of the window will save the current preset list for use in the project.  The   button in the lower left corner will revert the preset list to the default list that comes with the Smithy Asset.  Clicking the   in the window bar will exit the manager and discard any unsaved changes.   Accessed from the Unity Editor menu bar under  Window     Smithy     Preset Manager  or by pressing   Ctrl  +  Shift  +  R", 
            "title": "Probability Preset Manager"
        }, 
        {
            "location": "/editor/manager/#presets", 
            "text": "Presets hold a selection weight and a fill probability. When saved, they will appear in  node generation probability panels . Clicking their icon will set plug nodes to the preset weight value, and selection nodes to the preset fill probability.  Presets are usually displayed in Smithy by their icon, and icons can be set by clicking the   button that is superimposed on the preset icon. Doing so will open the following window:    The first row of sliders set the red, green, and blue values for the icon's foreground color.  The second row sets the red, green, and blue values for the icon's background color.  The lower panel of this window sets a  Font Awesome glyph  as the preset's icon.   To add a new preset to your project, click the   button.", 
            "title": "Presets"
        }, 
        {
            "location": "/editor/manager/#visualizer", 
            "text": "The visualizer updates automatically as you add, remove, or edit presets.  The right half of the preset manager window is a selection weight visualizer. Smithy simulates 10,000 selections (by default) and reports how often each preset was selected. By hovering over a column of the bar chart Smithy will report how often that preset has been selected, and the relative probability of that preset being selected.  The integer input in the upper right-hand corner represents the number of selections the simulation makes while updating. Higher values result in more accurate results, but are more performance-intensive and may result in lag when using this manager.", 
            "title": "Visualizer"
        }, 
        {
            "location": "/generation/", 
            "text": "Overview\n\n\nSmithy uses Generator objects to procedurally generate object hierarchies, both in the\n  Editor \nObject Assembler\n and at runtime.\n  When Generators are instanced, they build a reference collection of \n \nPlug Nodes\n . When needed, Generators are passed one or more GameObjects. The Generator then searches this object for \n \nSocket Nodes\n.\n\n\nIf any are found, the Generator finds \n \nPlug Nodes\n  that share \n \nTags\n with the Socket Node. The Generator will then make a selection from these Plugs, based on \nselection weight\n. The selected Plug's GameObject is instantiated as a child of the Socket object, and the Plug and Socket are \naligned\n and \nconnected\n in world space.\n\n\nThe Generator then checks the instanced Plug object for Sockets as well. If any are found, the process begins again, as long as the initial Socket object is still above its \nmaximum generation depth\n.\n\n\nGenerator Class\n\n\n\n\npublic class Generator(IEnumerable\nstring\n resourcePaths, int seed)\n\n\n\n\n\n\nThe runtime Generator class is named \nGenerator\n, and is the only class that actually handles the recursive procedural generation routine. Generators are objects, instanced like so:\n\n\nGenerator myGenerator = new Generator();\n\n\n\n\nThis will instantiate a new Generator object with an unseeded Random provider, and will create a plug reference collection of \nall\n Smithy-enabled objects in the \nResources\n folder. These properties can be changed by supplying the following parameters:\n\n\nParameters\n\n\nRandom Seed\n\n\nGenerators can be provided with an \nint\n value as a \nrandom seed\n. Generators that share the same seed and operating with the same inputs will generate consistent results every time.\n\n\nint mySeedValue = 42;\nvar myGenerator = new Generator(mySeedValue);\n\n\n\n\nSeeds can be set and tested in the \nEditor Object Assembler\n.\n\n\nA seed value of 0 will result in an unseeded Random generator.\n\n\nResource Paths\n\n\nBy default, Generators reference every Smithy-enabled object in a project's \nResources\n folder. However, Generators can also be passed an \nIEnumerable\nstring\n collection. These strings are paths relative to the \nResources\n folder of your Unity project, and will limit the plug reference collection the Generator is able to create:\n\n\nvar resourcePaths = new[]{\n/Level1/A\n, \n/Level1/B\n, \n/Level1/C\n};\nvar myGenerator = new Generator(resourcePaths);\n\n\n\n\nIn the example above, the Generator will \nonly\n look for \nPlug Nodes\n  from the \nResources/Level1/A\n, \nResources/Level1/B\n, and \nResources/Level1/C\n folders. This is useful in limiting the scope of objects that can be generated, as well as increasing generation performance.\n\n\nGeneration Options\n\n\nGenerators can be passed an array of \nGenerationOption[]\n, that modify the Generator's behavior. These options will affect every \nGenerate\n call the Generator makes. These same options can be passed on a \nper-call basis\n.\n\n\nGenerationOptions.DisableJitter\n\n\nPrevent Node \njitter\n from being applied on instantiation.\n\n\nGenerationOptions.DisableMaterialSelection\n\n\nPrevent Node \nmaterial selection\n from being applied on instantiation. All Plug objects will instantiate with their default materials.\n\n\nGenerationOptions.ForceFillSockets\n\n\nIgnore Socket \nFill Probability\n. All sockets in the hierarchy will be filled with Plugs.\n\n\nGenerationOptions.IgnoreSelectionWeight\n\n\nIgnore Plug \nSelection Weight\n. All plugs will have an equal possibility of selection.\n\n\n\n    \n\n    This can, in the case of very large selection sets, reduce the performance impact of generation. If your project has no use for weighted selections, you should always use this option.\n    \n\n  \n\n\nMethods\n\n\nGenerate\n\n\n\n\npublic GameObject Generate(GameObject baseGameObject)\n\npublic GameObject Generate(GameObject baseGameObject, GenerationOptions[] options)\n\n\n\n\n\n\nThe Generator recursively instantiates a \nGameObject\n hierarchy, staring from the provided GameObject. It will continue until all \nSocket Nodes\n have been \nchecked\n, or, the hierarchy reaches its \nmaximum generation depth\n.\n\n\nThis method returns a \nGameObject\n, an instance of the \nbaseGameObject\n parameter. In most cases, \nbaseGameObject\n will be a prefab, although any \nGameObject\n can be passed.\n\n\n  var myGenerator = new Generator();\n  var myGameObject = Resources.Load\nGameObject\n(\nbaseObject\n);\n\n  var myProceduralObject = myGenerator.Generate(myGameObject);\n\n\n\n\nIf the \nGameObject\n exists in the hierarchy, the Generator will not instantiate a new copy. Plugs will be generated for the extant copy.\n\n\npublic GameObject activeBaseObject;\n\nvoid Start()\n{\n  var myGenerator = new Generator();\n\n  myGenerator.Generate(activeBaseObject);     //This will still return a reference to \nactiveBaseObject\n.\n}\n\n\n\n\nKeep in mind that in most projects, creating a new generator \nfor each\n \nGenerate\n call is performance expensive, and is almost always unnecessary.\n\n\nAdditionally, \nGenerate\n can be passed an array of \nGenerationOption[]\n that operates in the same way the \nGenerator instantiation parameter does\n, but only over the single \nGenerate\n call.\n\n\nInclude\n\n\n\n\npublic void Include(IEnumerable\nGameObject\n includedAssets)\n\n\n\n\n\n\nThe Generator will search the supplied \nIEnumerable\nGameObject\n for \nPlug Nodes\n and add them the the Generator's Plug reference collection. Future Generate calls will also include these Plugs.\n\n\nvar morePlugs = GameObject.FindGameObjectsWithTag(\nSome_Tag\n);\nvar myGenerator = new Generator(\n/Foo\n);\n\nmyGenerator.Include(morePlugs);\n\n\n\n\nAsset Bundles\n\n\nAssetBundle Assets can be added to Generator selection sets by first loading the AssetBundle content then using \nInclude\n to add it to the Generator. As Generators can't be created from AssetBundles, this is currently the only way to generate from bundled content.\n\n\nTo build a Generator that selects from \nonly\n AssetBundle Assets, first create a new Generator with a Resource Path parameter that leads to an empty \nResource\n folder. Then, \nInclude\n the loaded AssetBundle content, like so:\n\n\nvar myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, \nmyassetBundle\n));\n\nvar myLoadedAssets = myLoadedAssetBundle.LoadAllAssets\nGameObject\n;\n\nvar myGenerator = new Generator(\n/EmptyFolder\n);\nmyGenerator.Include(myLoadedAssets);\n\n\n\n\nExclude\n\n\n\n\npublic void Exclude(IEnumerable\nGameObject\n excludedAssets)\n\n\n\n\n\n\nAny \nPlug Nodes\n in the \nexcludedAssets\n collection will be removed from the Generator's Plug reference collection, if they exist.\n\n\nvar oldPlugs = GameObject.FindGameObjectsWithTag(\nLevel1\n);\n\nmyGenerator.Exclude(oldPlugs);\n\n\n\n\nExclude\n is best used when managing Generators that operate over large reference collections, or very specific ones (such as selection sets based on achievements or player progress). Use \nExclude\n when it would be overly difficult, performance-intensive, or time-consuming to instantiate a new Generator with the appropriate Plug reference collection.\n\n\nSet Depth\n\n\n\n\npublic void SetDepth(int depth)\n\n\n\n\n\n\nSets the Generator's \nmaximum generation depth\n to the supplied \nint\n. Used when tying generation depth to a runtime-specific variable, or set of variables. Very useful in setting generation depth based on performance settings, for example.\n\n\nint depth;\n\nif (Application.platform == RuntimePlatform.Windows)\n{\n  depth = 20;\n}\nelse\n{\n  depth = 5;\n}\n\nvar myGenerator = new Generator();  \nmyGenerator.SetDepth(myDepth);", 
            "title": "Generation API"
        }, 
        {
            "location": "/generation/#overview", 
            "text": "Smithy uses Generator objects to procedurally generate object hierarchies, both in the\n  Editor  Object Assembler  and at runtime.\n  When Generators are instanced, they build a reference collection of    Plug Nodes  . When needed, Generators are passed one or more GameObjects. The Generator then searches this object for    Socket Nodes .  If any are found, the Generator finds    Plug Nodes   that share    Tags  with the Socket Node. The Generator will then make a selection from these Plugs, based on  selection weight . The selected Plug's GameObject is instantiated as a child of the Socket object, and the Plug and Socket are  aligned  and  connected  in world space.  The Generator then checks the instanced Plug object for Sockets as well. If any are found, the process begins again, as long as the initial Socket object is still above its  maximum generation depth .", 
            "title": "Overview"
        }, 
        {
            "location": "/generation/#generator-class", 
            "text": "public class Generator(IEnumerable string  resourcePaths, int seed)   The runtime Generator class is named  Generator , and is the only class that actually handles the recursive procedural generation routine. Generators are objects, instanced like so:  Generator myGenerator = new Generator();  This will instantiate a new Generator object with an unseeded Random provider, and will create a plug reference collection of  all  Smithy-enabled objects in the  Resources  folder. These properties can be changed by supplying the following parameters:", 
            "title": "Generator Class"
        }, 
        {
            "location": "/generation/#parameters", 
            "text": "", 
            "title": "Parameters"
        }, 
        {
            "location": "/generation/#random-seed", 
            "text": "Generators can be provided with an  int  value as a  random seed . Generators that share the same seed and operating with the same inputs will generate consistent results every time.  int mySeedValue = 42;\nvar myGenerator = new Generator(mySeedValue);  Seeds can be set and tested in the  Editor Object Assembler .  A seed value of 0 will result in an unseeded Random generator.", 
            "title": "Random Seed"
        }, 
        {
            "location": "/generation/#resource-paths", 
            "text": "By default, Generators reference every Smithy-enabled object in a project's  Resources  folder. However, Generators can also be passed an  IEnumerable string  collection. These strings are paths relative to the  Resources  folder of your Unity project, and will limit the plug reference collection the Generator is able to create:  var resourcePaths = new[]{ /Level1/A ,  /Level1/B ,  /Level1/C };\nvar myGenerator = new Generator(resourcePaths);  In the example above, the Generator will  only  look for  Plug Nodes   from the  Resources/Level1/A ,  Resources/Level1/B , and  Resources/Level1/C  folders. This is useful in limiting the scope of objects that can be generated, as well as increasing generation performance.", 
            "title": "Resource Paths"
        }, 
        {
            "location": "/generation/#generation-options", 
            "text": "Generators can be passed an array of  GenerationOption[] , that modify the Generator's behavior. These options will affect every  Generate  call the Generator makes. These same options can be passed on a  per-call basis .", 
            "title": "Generation Options"
        }, 
        {
            "location": "/generation/#generationoptionsdisablejitter", 
            "text": "Prevent Node  jitter  from being applied on instantiation.", 
            "title": "GenerationOptions.DisableJitter"
        }, 
        {
            "location": "/generation/#generationoptionsdisablematerialselection", 
            "text": "Prevent Node  material selection  from being applied on instantiation. All Plug objects will instantiate with their default materials.", 
            "title": "GenerationOptions.DisableMaterialSelection"
        }, 
        {
            "location": "/generation/#generationoptionsforcefillsockets", 
            "text": "Ignore Socket  Fill Probability . All sockets in the hierarchy will be filled with Plugs.", 
            "title": "GenerationOptions.ForceFillSockets"
        }, 
        {
            "location": "/generation/#generationoptionsignoreselectionweight", 
            "text": "Ignore Plug  Selection Weight . All plugs will have an equal possibility of selection.  \n     \n    This can, in the case of very large selection sets, reduce the performance impact of generation. If your project has no use for weighted selections, you should always use this option.", 
            "title": "GenerationOptions.IgnoreSelectionWeight"
        }, 
        {
            "location": "/generation/#methods", 
            "text": "", 
            "title": "Methods"
        }, 
        {
            "location": "/generation/#generate", 
            "text": "public GameObject Generate(GameObject baseGameObject)\n\npublic GameObject Generate(GameObject baseGameObject, GenerationOptions[] options)   The Generator recursively instantiates a  GameObject  hierarchy, staring from the provided GameObject. It will continue until all  Socket Nodes  have been  checked , or, the hierarchy reaches its  maximum generation depth .  This method returns a  GameObject , an instance of the  baseGameObject  parameter. In most cases,  baseGameObject  will be a prefab, although any  GameObject  can be passed.    var myGenerator = new Generator();\n  var myGameObject = Resources.Load GameObject ( baseObject );\n\n  var myProceduralObject = myGenerator.Generate(myGameObject);  If the  GameObject  exists in the hierarchy, the Generator will not instantiate a new copy. Plugs will be generated for the extant copy.  public GameObject activeBaseObject;\n\nvoid Start()\n{\n  var myGenerator = new Generator();\n\n  myGenerator.Generate(activeBaseObject);     //This will still return a reference to  activeBaseObject .\n}  Keep in mind that in most projects, creating a new generator  for each   Generate  call is performance expensive, and is almost always unnecessary.  Additionally,  Generate  can be passed an array of  GenerationOption[]  that operates in the same way the  Generator instantiation parameter does , but only over the single  Generate  call.", 
            "title": "Generate"
        }, 
        {
            "location": "/generation/#include", 
            "text": "public void Include(IEnumerable GameObject  includedAssets)   The Generator will search the supplied  IEnumerable GameObject  for  Plug Nodes  and add them the the Generator's Plug reference collection. Future Generate calls will also include these Plugs.  var morePlugs = GameObject.FindGameObjectsWithTag( Some_Tag );\nvar myGenerator = new Generator( /Foo );\n\nmyGenerator.Include(morePlugs);", 
            "title": "Include"
        }, 
        {
            "location": "/generation/#asset-bundles", 
            "text": "AssetBundle Assets can be added to Generator selection sets by first loading the AssetBundle content then using  Include  to add it to the Generator. As Generators can't be created from AssetBundles, this is currently the only way to generate from bundled content.  To build a Generator that selects from  only  AssetBundle Assets, first create a new Generator with a Resource Path parameter that leads to an empty  Resource  folder. Then,  Include  the loaded AssetBundle content, like so:  var myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath,  myassetBundle ));\n\nvar myLoadedAssets = myLoadedAssetBundle.LoadAllAssets GameObject ;\n\nvar myGenerator = new Generator( /EmptyFolder );\nmyGenerator.Include(myLoadedAssets);", 
            "title": "Asset Bundles"
        }, 
        {
            "location": "/generation/#exclude", 
            "text": "public void Exclude(IEnumerable GameObject  excludedAssets)   Any  Plug Nodes  in the  excludedAssets  collection will be removed from the Generator's Plug reference collection, if they exist.  var oldPlugs = GameObject.FindGameObjectsWithTag( Level1 );\n\nmyGenerator.Exclude(oldPlugs);  Exclude  is best used when managing Generators that operate over large reference collections, or very specific ones (such as selection sets based on achievements or player progress). Use  Exclude  when it would be overly difficult, performance-intensive, or time-consuming to instantiate a new Generator with the appropriate Plug reference collection.", 
            "title": "Exclude"
        }, 
        {
            "location": "/generation/#set-depth", 
            "text": "public void SetDepth(int depth)   Sets the Generator's  maximum generation depth  to the supplied  int . Used when tying generation depth to a runtime-specific variable, or set of variables. Very useful in setting generation depth based on performance settings, for example.  int depth;\n\nif (Application.platform == RuntimePlatform.Windows)\n{\n  depth = 20;\n}\nelse\n{\n  depth = 5;\n}\n\nvar myGenerator = new Generator();  \nmyGenerator.SetDepth(myDepth);", 
            "title": "Set Depth"
        }, 
        {
            "location": "/edition_specific/editions/", 
            "text": "Smithy Editions\n\n\nSmithy comes in three developer additions and a free reader asset.\n\n\n\n\n\n\n\n\nReader\n\n\nStandard\n\n\nDesigner\n\n\nPro\n\n\n\n\n\n\n\n\n\n\nContent Cell\n\n\nContent Cell\n\n\nContent Cell\n\n\nContent Cell\n\n\n\n\n\n\nContent Cell\n\n\nContent Cell\n\n\nContent Cell\n\n\nContent Cell", 
            "title": "Editions Overview"
        }, 
        {
            "location": "/edition_specific/editions/#smithy-editions", 
            "text": "Smithy comes in three developer additions and a free reader asset.     Reader  Standard  Designer  Pro      Content Cell  Content Cell  Content Cell  Content Cell    Content Cell  Content Cell  Content Cell  Content Cell", 
            "title": "Smithy Editions"
        }, 
        {
            "location": "/edition_specific/reader/", 
            "text": "", 
            "title": "Reader"
        }, 
        {
            "location": "/edition_specific/exporter/", 
            "text": "", 
            "title": "Exporter"
        }, 
        {
            "location": "/edition_specific/runtime_editor/", 
            "text": "", 
            "title": "Runtime Editor"
        }, 
        {
            "location": "/troubleshooting/", 
            "text": "Occasionally, the Unity Editor will lose or corrupt the fonts and glyphs in the Smithy Editor.\n\n\nThis is a known problem that Unity has with dynamic font loading. This occurs most frequently when alt-tabbing away from Unity.", 
            "title": "Troubleshooting"
        }
    ]
}